<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: UNIX/Linux | OPS Notes By 枯木]]></title>
  <link href="http://kumu-Linux.github.io/blog/categories/unix-slash-linux/atom.xml" rel="self"/>
  <link href="http://kumu-Linux.github.io/"/>
  <updated>2014-04-22T11:15:55+08:00</updated>
  <id>http://kumu-Linux.github.io/</id>
  <author>
    <name><![CDATA[枯木]]></name>
    <email><![CDATA[1988.wulei@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux基础命令-1]]></title>
    <link href="http://kumu-Linux.github.io/blog/2014/04/22/linux-base1/"/>
    <updated>2014-04-22T11:09:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2014/04/22/linux-base1</id>
    <content type="html"><![CDATA[<blockquote><p>Linux下一切皆文件</p></blockquote>

<!--more-->


<h3><code>pwd</code>、<code>cd</code></h3>

<p><code>bash
$ pwd       # 查看当前所在目录
$ pwd -P    # 获取当前真实路径，适用于软链接目录
$ cd        # 直接cd，默认到当前用户家目录下
$ cd ~      # cd ~，到当前用户家目录下
$ cd -      # 返回到前一目录
$ cd ..     # 回到上一级目录
$ cd ~username    # 到某个用户的家目录下
</code></p>

<h3><code>mkdir</code>[创建目录]、<code>touch</code>[新建空文件]</h3>

<p><code>bash
$ mkdir /a/b/c -p       # 递归创建目录
$ mkdir -m 700 test     # 创建自定义权限目录
</code></p>

<h3><code>cp</code>复制命令</h3>

<p><code>bash
$ cp -rpv src dst        # r递归复制用于复制目录，p保留文件目录属性，v显示复制状态
</code></p>

<h3><code>cat</code>、<code>more</code>、<code>less</code>、<code>tail</code>、<code>head</code> [查看文件内容]</h3>

<p><code>bash
$ cat /etc/passwd           # 查看文件内容
$ cat -n /etc/passwd        # -n选项显示内容所在行号
$ more /etc/passwd          # 查看文件内容，支持上下翻页
$ less /etc/passwd          # 查看文件内容，支持上下翻页，较more更灵活
$ head -n 10 /etc/passwd    # 查看头10行文件内容
$ tail -n 10 /etc/passwd    # 看看文件末尾10行内容
$ tail -f /var/log/messages # 动态查看新增日志内容，非常实用
</code></p>

<h3><code>ls</code></h3>

<p><code>bash
$ ls        # 列出当前文件
$ ls -l     # -l详细方式列出当前文件
$ ls -ld    # -d查看目录的详细属性
$ ls -la    # -a列出隐藏文件
$ ls -lt    # -t以修改时间排序文件
$ ls -lh    # -h以可读的方式显示
$ ls -i     # -i获取文件inode
</code></p>

<h3><code>history</code> 查看历史记录</h3>

<p><code>bash
$ history            # 查看当前用户命令执行历史记录
$ history -c         # 清空当前终端历史记录，
</code></p>

<p>默认存放路径：<code>~/.bash_history</code></p>

<p><code>history</code>一些有用的配置：</p>

<p>``` bash
$ vim ~/.bashrc</p>

<h1>添加如下内容</h1>

<h1>忽略[连续]重复命令</h1>

<p>HISTCONTROL=ignoredups</p>

<h1>清除重复命令</h1>

<h1>HISTCONTROL=erasedups</h1>

<h1>忽略特定命令</h1>

<p>HISTIGNORE="[   ]<em>:ls:ll:cd:vi:pwd:sync:exit:history</em>"</p>

<h1>命令历史文件大小10M</h1>

<p>HISTFILESIZE=1000000000</p>

<h1>保存历史命令条数10W</h1>

<p>HISTSIZE=1000000
```</p>

<p>以上配置可以<code>set | grep HIST</code>查看以上选项配置。</p>

<p>当打开多个终端，关闭其中一个终端时，会覆盖其他终端的命令历史， 这里可以采用追加的方式避免命令历史文件 <code>.bash_history</code> 文件被覆盖。</p>

<p>``` bash
$ vim ~/.bashrc</p>

<h1>添加如下内容</h1>

<p>shopt -s histappend
```</p>

<h3><code>type</code> 查看命令类型</h3>

<p>Linux命令分为shell内置命令和外部命令，可以通过<code>type</code>得知命令类型</p>

<p><code>bash
$ type passwd
passwd is /usr/bin/passwd
$ type cd
cd is a shell builtin
</code></p>

<h3><code>file</code>查看文件类型、<code>stat</code>查看文件<code>inode</code>信息</h3>

<p><code>bash
$ file /etc/passwd
/etc/passwd: ASCII text
$ file /bin/pwd
/bin/pwd: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, stripped
$ stat /bin/pwd
  File: `/bin/pwd'
  Size: 31656     Blocks: 64         IO Block: 4096   regular file
Device: 803h/2051d Inode: 1972888     Links: 1
Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2014-04-05 03:07:04.983044299 +0800
Modify: 2013-11-22 23:36:45.000000000 +0800
Change: 2013-12-26 12:39:58.569332497 +0800
</code></p>

<h3><code>man</code> 、<code>info</code> 、<code>--help</code>、<code>help</code>获取命令的帮助</h3>

<p><strong>注：</strong>其中<code>help</code>只能获取shell内置命令的帮助</p>

<h3><code>whereis</code>、<code>which</code></h3>

<p><strong>注：</strong>两个命令只能获取非内嵌的shell命令
<code>whereis</code>：定位命令的二进制、源码和帮助手册
<code>which</code>：获取命令的位置，默认先获取alias别名，可以使用<code>--skip-alias</code>选项跳过别名</p>

<h3><code>alias</code>、<code>unalias</code></h3>

<p>``` bash
$ alias     # 查看当前环境别名  <br/>
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias vi='vim'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'</p>

<h1>此处which别名可以获知为何默认which会先展示别名再展示实际命令的位置</h1>

<p>$ alias c=clear # 设置别名c对应clear
$ unalias c     # 取消设置的别名
```</p>

<h3>Shell下的一些快捷键</h3>

<ul>
<li> <code>Tab</code>       --  补全</li>
<li> <code>Esc+.</code>    --  获取上个命令最后一个词</li>
<li> <code>Ctrl+l</code>    --  清屏，类似 clear 命令</li>
<li> <code>Ctrl+r</code>    --  查找历史命令</li>
<li> <code>Ctrl+c</code>    --  终止</li>
<li> <code>Ctrl+k</code>    --  删除此处至末尾所有内容</li>
<li> <code>Ctrl+u</code>    --  删除此处至开始所有内容</li>
<li> <code>Ctrl+a/e</code>  --  回到行首/行尾</li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux性能优化--CPU[备忘]]]></title>
    <link href="http://kumu-Linux.github.io/blog/2014/04/21/performance-cpu/"/>
    <updated>2014-04-21T17:52:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2014/04/21/performance-cpu</id>
    <content type="html"><![CDATA[<p>Linux性能相关可以从以下几方面入手：</p>

<ul>
<li>CPU</li>
<li>Memory</li>
<li>IO</li>
<li>Network</li>
</ul>


<!--more-->


<p>这些子系统之间关系相互彼此依赖的，任何一个高负载都会导致其他子系统出现问题，比如：</p>

<ul>
<li>大量的页请求导致内存队列的拥塞</li>
<li>网卡的大吞吐量可能导致更多的CPU开销</li>
<li>大量的CPU开销又尝试更多的内存使用请求</li>
<li>大量来自内存的磁盘写请求可能导致更多的cpu以及IO问题</li>
</ul>


<h2>CPU</h2>

<p>主要关注点在运行队列、利用率、上下文切换</p>

<ul>
<li>Run Queues - 每个处理器应该运行队列不超过1-3个线程，一个双核处理器应该运行队列不要超过6个线程</li>
<li>CPU Utiliation - 如果一个CPU被充分使用，利用率分类之间均衡的比例应该是：

<ul>
<li>65% - 70% User Time</li>
<li>30% - 35% System Time</li>
<li>0% - %5 Idle Time</li>
</ul>
</li>
<li>Context Switches - 上下文切换的数目直接关系到CPU的使用率，如果CPU利用率保持在上述均衡状态时，大量的上下文切换是正常的</li>
</ul>


<p><code>bash
$ vmstat 2
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 4  0  42808 130596  70836 23084420    0    0     0     5    0    0  5  2 93  0  0
 8  0  42808 129388  70836 23084904    0    0     0    30 10987 80554  9  3 88  0  0
 6  0  42808 137428  70828 23076148    0    0     0    26 11129 80587  9  3 88  0  0
</code></p>

<ul>
<li><code>r</code> The amount of threads in the run queue. These are threads that are runnable, but the CPU is not available to execute them.

<ul>
<li>当前<code>运行队列中线程的数目</code>.代表线程处于可运行状态,但CPU还未能执行.</li>
</ul>
</li>
<li><code>b</code> This is the number of processes blocked and waiting on IO requests to finish.

<ul>
<li>当前<code>进程阻塞并等待IO请求完成的数目</code></li>
</ul>
</li>
<li><code>in</code> This is the number of interrupts being processed.

<ul>
<li>当前<code>中断</code>被处理的数目</li>
</ul>
</li>
<li><code>cs</code> This is the number of context switches currently happening on the system.

<ul>
<li>当前kernel system中,发生<code>上下文切换</code>的数目</li>
</ul>
</li>
<li><code>us</code> This is the percentage of user CPU utilization.

<ul>
<li>CPU利用率的百分比</li>
</ul>
</li>
<li><code>sys</code> This is the percentage of kernel and interrupts utilization.

<ul>
<li><code>内核和中断利用率的百分比</code></li>
</ul>
</li>
<li><code>wa</code> This is the percentage of idle processor time due to the fact that ALL runnable threads are blocked waiting on IO.

<ul>
<li>所有<code>可运行状态线程被阻塞在等待IO请求的百分比</code></li>
</ul>
</li>
<li><code>id</code> This is the percentage of time that the CPU is completely idle.

<ul>
<li>CPU空闲时间的百分比</li>
</ul>
</li>
</ul>


<p><code>bash
$ mpstat -P ALL 1   # 查看单个cpu利用率情况，同`sar -P ALL 1`
16时17分05秒  CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s
16时17分07秒  all    2.62    0.00    0.29    0.10    0.04    0.33    0.00   96.61  11159.00
16时17分07秒    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00   1000.50
16时17分07秒    1    0.00    0.00    0.00    1.01    0.00    0.00    0.00   98.99     26.00
16时17分07秒    2    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00      0.00
16时17分07秒    3    0.50    0.00    0.00    0.00    0.00    0.00    0.00   99.50      0.00
16时17分07秒    4    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00      0.00
16时17分07秒    5    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00      0.00
</code></p>

<p><code>bash
$ while :; do ps eo pid,ni,pri,pcpu,psr,comm | \
grep 'mysqld'; sleep 1 ;done # ps通过查看psr队列获取进程占用哪个cpu
</code></p>

<p>top也可以实时查看占用哪个cpu
<code>bash
$ top -p `pgrep mysql | xargs | tr " " ","` # 执行如下命令之后
</code></p>

<p><code>pri</code>优先级动态值，<code>ni</code>为静态值，root用户可以调高nice优先级[-20~19]，-20为优先级最高，普通用户只能调低优先级，两者关系：<code>pri[new]=pri[old]+nice</code></p>

<p>监控CPU性能由以下几个部分组成：</p>

<ul>
<li>1、检查system的运行队列，以及确定不要超过每个处理器3个可运行状态线程的限制</li>
<li>2、确定CPU利用率中user/system比例维持在70/30</li>
<li>3、当CPU开销更多的时间在system mode，那就说明已经超负荷并且应该尝试重新调度优先级</li>
<li>4、当I/O处理增长，CPU相应的应用将会受到影响</li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[svn and git Server备忘]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/12/09/svn-git/"/>
    <updated>2013-12-09T13:58:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/12/09/svn-git</id>
    <content type="html"><![CDATA[<h2><u>Git Server with ssh</u></h2>

<!--more-->


<ul>
<li>Server</li>
</ul>


<p><code>bash
useradd -s /usr/bin/git-shell git   //创建git用户
git init --bare /home/git/testrepo  //初始化名为testrepo，Server端操作
mkdir /home/git/.ssh -p
vim .ssh/authorized_keys            //加入客户端ssh公钥，设置ssh公钥认证
chmod 700 /home/git/.ssh/
chmod 400 /home/git/.ssh/authorized_keys
chown git:git -R /home/git
</code></p>

<p>注意：如果是root用户执行的命令，需要修改权限如下
<code>
chow -R git:git testrepo
</code></p>

<ul>
<li>Client</li>
</ul>


<p><code>bash
git clone git@sevrer_ip:/home/git/testrepo  //克隆repo
</code></p>

<p>具体操作<br/>
<code>bash
cd testrepo                         //进入本地版本库
echo "hello" &gt;&gt; test                //新建测试文件
git add test                        //添加到git缓存
git commit -m "first commit" test   //本地提交
git push -u origin master           //提交给远程服务器
git pull                            //客户端拉取数据
</code></p>

<h2><u>Svn Server with apache &amp;&amp; ldap</u></h2>

<p><code>bash
yum install subversion mod_dav_svn -y
</code></p>

<p>yum安装后会生成subversion.conf并添加相应模块配置
``` bash</p>

<h1>grep LoadModule /etc/httpd/conf.d/subversion.conf</h1>

<p>LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
```</p>

<p>svn创建库<br/>
<code>bash
svnadmin create --fs-type fsfs /var/www/svn
chown apache:apache -R /var/www/svn
</code></p>

<p>设置ldap认证<br/>
``` bash</p>

<h1>grep -vE '<sup>$|<sup>#'</sup></sup> /etc/httpd/conf.d/subversion.conf</h1>

<p>LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
<Location /svn></p>

<pre><code>DAV svn 
SVNPath /var/www/svn
AuthBasicProvider ldap
AuthType Basic
AuthzLDAPAuthoritative off
AuthName "Please provide your windows login credentials to continue."
AuthLDAPURL "ldap://ldap_ip/ou=users,ou=test,dc=intranet,dc=test,dc=com?sAMAccountName" NONE
AuthLDAPBindDN "test@intranet.test.com"
AuthLDAPBindPassword password 
require valid-user
</code></pre>

<p></Location>
```</p>

<p>启动apache<br/>
<code>
service httpd start
</code></p>

<p>浏览器登陆<br/>
<a href="http://svn_ip/svn">http://svn_ip/svn</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修改CentOS/RHEL rsync监听地址]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/11/07/rsync/"/>
    <updated>2013-11-07T10:35:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/11/07/rsync</id>
    <content type="html"><![CDATA[<p>为了安全起见，服务器不对外提供的服务尽量不监听外网地址的，rsync也不例外。由于CentOS/RHEL中rpm安装的rsync为非独立进程，需要依赖xinetd进程。笔者一开始尝试修改rsync的配置文件<code>rsyncd.conf</code>中加入<code>address = 192.168.80.128</code>，重启xinetd服务，发现修改没有生效。</p>

<!--more-->


<p><code>bash
...
tcp        0      0 0.0.0.0:873                 0.0.0.0:*       ...
...
</code></p>

<p>因为CentOS/RHEL是依赖xinetd的，所以我就想到了xinetd配置文件<code>/etc/xinetd.conf</code>，发现选项<code># bind       =</code>，于是修改如下</p>

<p>``` bash
...</p>

<pre><code>bind        = 192.168.80.128    # 此处ip填写主机本地ip即可
</code></pre>

<p>...
```</p>

<p>修改完成保存，重启xinetd程序，修改生效</p>

<p><code>bash
...
tcp        0      0 192.168.80.128:873               0.0.0.0:*                   LISTEN      25967/xinetd
...
</code></p>

<p>当然你也可以直接不依赖xinetd修改监听地址，直接使用命令启动rsync，如下</p>

<p><code>bash
rsync --address=192.168.80.128 --config=/etc/rsyncd.conf --daemon
</code></p>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh的一些安全设定]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/09/26/ssh-safe/"/>
    <updated>2013-09-26T10:42:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/09/26/ssh-safe</id>
    <content type="html"><![CDATA[<center><img src="http://kumu-Linux.github.io/images/nmap_ssh.jpg" width="500"></center>




<!--more-->


<p>ssh是我们日常工作中必不可少的工具，所以它的安全性也是异常重要了，这里笔者简单介绍了一些ssh配置中需要注意的几个点。</p>

<!--more-->


<p>首先,作为root用户登录并备份原始文件，输入下面的命令：</p>

<p><code>bash
cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
</code></p>

<h3>1、调整认证时限(默认单位为s)，即当用户登录ssh之后，要求输入密码的时间限制，规定时间没有输入则自动断线：</h3>

<p><code>bash
LoginGraceTime 60
</code></p>

<h3>2、最好限制root用户远程登录，修改如下：</h3>

<p><code>bash
PermitRootLogin no
</code></p>

<h3>3、关闭X11转发，防止额外的信息泄露</h3>

<p><code>bash
X11Forwarding no
</code></p>

<h3>4、取消以下两行的注释，使得登录后显示一些信息</h3>

<p><code>bash
PrintMotd yes
PrintLastLog yes
</code></p>

<h3>5、编辑<code>/etc/motd</code>文件，添加一些警告信息，如下</h3>

<p><code>bash
This computer system is for authorized users only. All activity
is logged and regularly checked. Individuals using this system
without authority or in excess of their authority are subject to
having all their services revoked...
</code></p>

<h3>6、关闭ssh闲置会话</h3>

<p><code>bash
ClientAliveInterval 60        
ClientAliveCountMax 5
</code></p>

<ul>
<li>ClientAliveInterval设置表示如果超过这么长时间没有收到客户端的任何数据，将通过安全通道向客户端发送一个"alive"消息，并等候应答，单位默认为s。</li>
<li>ClientAliveCountMax表示在未收到任何客户端回应前最多允许发送多少个"alive"消息，这是设置5次</li>
</ul>


<p>以上也就是客户端如果60*5=300s，即5分钟如果没有任何操作，则空闲连接会被强制断开，关闭时提示如下</p>

<pre><code>Connection to x.x.x.x closed by remote host.
Connection to x.x.x.x closed.
</code></pre>

<h3>7、开启TCPKeepAlive</h3>

<p><code>bash
TCPKeepAlive yes
</code></p>

<p>TCPKeepAlive指定系统是否向客户端发送TCP keepalive消息，这种消息可以检测到死连接、连接不当关闭、客户端崩溃等异常，避免僵尸进程产生，推荐开启。</p>

<h3>8、修改ssh默认端口22</h3>

<p><code>bash
Port xxxx   #自定义端口
</code></p>

<h3>9、设置允许登录的ssh用户</h3>

<p><code>bash
AllowUsers test1 test2 test3
</code></p>

<p>也可以设置允许的组</p>

<p><code>bash
AllowGroups admin
</code></p>

<h3>10、关闭不必要的认证</h3>

<p>如果可以，只允许公钥认证，关闭其它认证方式</p>

<p><code>bash
PasswordAuthentication no
ChallengeResponseAuthentication no
</code></p>

<p>基本的一个设置就是以上的部分了内容了，还可以结合<code>fail2ban</code>更好的保护ssh的安全。关于<code>fail2ban</code>下次介绍，其实很多网友已经写了很多相关的博文了。</p>

<h3>参考文章</h3>

<ul>
<li><a href="http://blog.licess.org/sshd_config/">sshd_config配置</a></li>
<li><a href="http://lamp.linux.gov.cn/OpenSSH/sshd_config.html">sshd_config中文手册</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/aix/library/au-sshsecurity/">SSH 安全性和配置入门</a></li>
<li><a href="http://www.amazon.com/CentOS-6-Linux-Server-Cookbook/dp/1849519021">CentOS 6 Linux Server Cookbook </a></li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
</feed>
