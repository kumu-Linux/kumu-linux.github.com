<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: UNIX/Linux | OPS Notes By 枯木]]></title>
  <link href="http://kumu-Linux.github.io/blog/categories/unix-slash-linux/atom.xml" rel="self"/>
  <link href="http://kumu-Linux.github.io/"/>
  <updated>2014-05-28T12:00:52+08:00</updated>
  <id>http://kumu-Linux.github.io/</id>
  <author>
    <name><![CDATA[枯木]]></name>
    <email><![CDATA[1988.wulei@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ubuntu14.04重启网络问题]]></title>
    <link href="http://kumu-Linux.github.io/blog/2014/05/28/ubuntu-network-br0/"/>
    <updated>2014-05-28T11:38:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2014/05/28/ubuntu-network-br0</id>
    <content type="html"><![CDATA[<p>Stopping or restarting the networking job is not supported.<br/>
Use ifdown &amp; ifup to reconfigure desired interface.</p>

<!--more-->


<p>Ubuntu14.04重启网络出现如下问题：</p>

<p>``` bash</p>

<h1>cat /etc/issue</h1>

<p>Ubuntu 14.04 LTS \n \l</p>

<h1>service  networking restart</h1>

<p>stop: Job failed while stopping
start: Job is already running: networking</p>

<h1>tail -f /var/log/upstart/networking.log</h1>

<p>Stopping or restarting the networking job is not supported.
Use ifdown &amp; ifup to reconfigure desired interface.
```</p>

<ul>
<li>重启指定网卡</li>
</ul>


<p>``` bash</p>

<h1>ifdown eth0 &amp;&amp; ifup eth0</h1>

<p>```</p>

<ul>
<li>重启除lo网卡的所有网卡</li>
</ul>


<p>``` bash</p>

<h1>ifdown --exclude=lo -a &amp;&amp; sudo ifup --exclude=lo -a</h1>

<p>```</p>

<ul>
<li>配置桥接</li>
</ul>


<p>``` bash</p>

<h1>apt-get install bridge-utils</h1>

<h1>cat /etc/network/interfaces</h1>

<p>auto lo
iface lo inet loopback</p>

<p>auto eth0
iface eth0 inet manual</p>

<p>auto br0
iface br0 inet static
address 192.168.0.10
netmask 255.255.255.0
gateway 192.168.1.1
bridge_ports eth0
bridge_stp off
bridge_fd 0
bridge_maxwait 0
dns-nameservers 192.168.1.1</p>

<h1>ifup br0</h1>

<h1>brctl  show</h1>

<p>bridge name bridge id       STP enabled interfaces
br0     8000.02000a0080e1   no      eth0
```</p>

<ul>
<li><a href="https://bugs.launchpad.net/ubuntu/+source/ifupdown/+bug/1301015">Networking does not restart</a></li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh MaxAuthTries]]></title>
    <link href="http://kumu-Linux.github.io/blog/2014/05/21/ssh-maxauthtries/"/>
    <updated>2014-05-21T23:05:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2014/05/21/ssh-maxauthtries</id>
    <content type="html"><![CDATA[<p>新建了一个Ubuntu14.04的虚拟机，使用xshell登陆，刚输入用户名后却直接抛出了 <code>Too many authentication failures for username</code> 的错误。ssh登陆失败尝试次数和<code>MaxAuthTries</code>值相关，直接<code>man sshd_config</code>获取该参数说明，得到如下内容：</p>

<!--more-->


<blockquote><p>MaxAuthTries</p>

<pre><code>Specifies the maximum number of authentication attempts permitted per connection.  
Once the number of failures reaches half this value, 
additional failures are logged.  The default is 6.
</code></pre></blockquote>

<p>让我很诧异的是，关键尼玛我还没有输入密码什么的啊，只是输入一个用户名就报错了。于是测试虚拟机本地ssh登陆，登陆正常，其它Linux主机登陆测试也正常，再测试xshell，依然是输入用户名之后报之前同样的错误。ssh本地<code>debug</code>模式再看下过程</p>

<p><code>bash
$ ssh -v 127.0.0.1
... ...
debug1: Trying private key: /home/test/.ssh/id_rsa
debug1: Trying private key: /home/test/.ssh/id_dsa
debug1: Trying private key: /home/test/.ssh/id_ecdsa
debug1: Trying private key: /home/test/.ssh/id_ed25519
debug1: Next authentication method: password
test@127.0.0.1's password:
... ...
</code></p>

<p>debug模式看到这里，我自己有点明白了，ssh验证过程是先尝试私钥再进行密码，查看Xagent开启了3个私钥agent，所以3次没有匹配到私钥之后就断开报错了。<code>MaxAuthTries</code>值默认为6，但是<code>Once the number of failures reaches half this value</code>尝试次数达到设定值一半之后就不能再尝试了。</p>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux性能优化--CPU[备忘]]]></title>
    <link href="http://kumu-Linux.github.io/blog/2014/04/21/performance-cpu/"/>
    <updated>2014-04-21T17:52:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2014/04/21/performance-cpu</id>
    <content type="html"><![CDATA[<p>Linux性能相关可以从以下几方面入手：</p>

<ul>
<li>CPU</li>
<li>Memory</li>
<li>IO</li>
<li>Network</li>
</ul>


<!--more-->


<p>这些子系统之间关系相互彼此依赖的，任何一个高负载都会导致其他子系统出现问题，比如：</p>

<ul>
<li>大量的页请求导致内存队列的拥塞</li>
<li>网卡的大吞吐量可能导致更多的CPU开销</li>
<li>大量的CPU开销又尝试更多的内存使用请求</li>
<li>大量来自内存的磁盘写请求可能导致更多的cpu以及IO问题</li>
</ul>


<h2>CPU</h2>

<p>主要关注点在运行队列、利用率、上下文切换</p>

<ul>
<li>Run Queues - 每个处理器应该运行队列不超过1-3个线程，一个双核处理器应该运行队列不要超过6个线程</li>
<li>CPU Utiliation - 如果一个CPU被充分使用，利用率分类之间均衡的比例应该是：

<ul>
<li>65% - 70% User Time</li>
<li>30% - 35% System Time</li>
<li>0% - %5 Idle Time</li>
</ul>
</li>
<li>Context Switches - 上下文切换的数目直接关系到CPU的使用率，如果CPU利用率保持在上述均衡状态时，大量的上下文切换是正常的</li>
</ul>


<p><code>bash
$ vmstat 2
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 4  0  42808 130596  70836 23084420    0    0     0     5    0    0  5  2 93  0  0
 8  0  42808 129388  70836 23084904    0    0     0    30 10987 80554  9  3 88  0  0
 6  0  42808 137428  70828 23076148    0    0     0    26 11129 80587  9  3 88  0  0
</code></p>

<ul>
<li><code>r</code> The amount of threads in the run queue. These are threads that are runnable, but the CPU is not available to execute them.

<ul>
<li>当前<code>运行队列中线程的数目</code>.代表线程处于可运行状态,但CPU还未能执行.</li>
</ul>
</li>
<li><code>b</code> This is the number of processes blocked and waiting on IO requests to finish.

<ul>
<li>当前<code>进程阻塞并等待IO请求完成的数目</code></li>
</ul>
</li>
<li><code>in</code> This is the number of interrupts being processed.

<ul>
<li>当前<code>中断</code>被处理的数目</li>
</ul>
</li>
<li><code>cs</code> This is the number of context switches currently happening on the system.

<ul>
<li>当前kernel system中,发生<code>上下文切换</code>的数目</li>
</ul>
</li>
<li><code>us</code> This is the percentage of user CPU utilization.

<ul>
<li>CPU利用率的百分比</li>
</ul>
</li>
<li><code>sys</code> This is the percentage of kernel and interrupts utilization.

<ul>
<li><code>内核和中断利用率的百分比</code></li>
</ul>
</li>
<li><code>wa</code> This is the percentage of idle processor time due to the fact that ALL runnable threads are blocked waiting on IO.

<ul>
<li>所有<code>可运行状态线程被阻塞在等待IO请求的百分比</code></li>
</ul>
</li>
<li><code>id</code> This is the percentage of time that the CPU is completely idle.

<ul>
<li>CPU空闲时间的百分比</li>
</ul>
</li>
</ul>


<p><code>bash
$ mpstat -P ALL 1   # 查看单个cpu利用率情况，同`sar -P ALL 1`
16时17分05秒  CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s
16时17分07秒  all    2.62    0.00    0.29    0.10    0.04    0.33    0.00   96.61  11159.00
16时17分07秒    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00   1000.50
16时17分07秒    1    0.00    0.00    0.00    1.01    0.00    0.00    0.00   98.99     26.00
16时17分07秒    2    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00      0.00
16时17分07秒    3    0.50    0.00    0.00    0.00    0.00    0.00    0.00   99.50      0.00
16时17分07秒    4    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00      0.00
16时17分07秒    5    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00      0.00
</code></p>

<p><code>bash
$ while :; do ps -eo pid,ni,pri,pcpu,psr,comm | \
grep 'mysqld'; sleep 1 ;done # ps通过查看psr队列获取进程占用哪个cpu
</code></p>

<p>top也可以实时查看占用哪个cpu
<code>bash
$ top -p `pgrep mysql | xargs | tr " " ","` # 执行如上命令之后输入`f`,然后输入`j`回车即可
</code></p>

<p><code>pri</code>优先级动态值，<code>ni</code>为静态值，root用户可以调高nice优先级[-20~19]，-20为优先级最高，普通用户只能调低优先级，两者关系：<code>pri[new]=pri[old]+nice</code></p>

<p>监控CPU性能由以下几个部分组成：</p>

<ul>
<li>1、检查system的运行队列，以及确定不要超过每个处理器3个可运行状态线程的限制</li>
<li>2、确定CPU利用率中user/system比例维持在70/30</li>
<li>3、当CPU开销更多的时间在system mode，那就说明已经超负荷并且应该尝试重新调度优先级</li>
<li>4、当I/O处理增长，CPU相应的应用将会受到影响</li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[svn and git Server备忘]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/12/09/svn-git/"/>
    <updated>2013-12-09T13:58:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/12/09/svn-git</id>
    <content type="html"><![CDATA[<h2><u>Git Server with ssh</u></h2>

<!--more-->


<ul>
<li>Server</li>
</ul>


<p><code>bash
useradd -s /usr/bin/git-shell git   //创建git用户
git init --bare /home/git/testrepo  //初始化名为testrepo，Server端操作
mkdir /home/git/.ssh -p
vim .ssh/authorized_keys            //加入客户端ssh公钥，设置ssh公钥认证
chmod 700 /home/git/.ssh/
chmod 400 /home/git/.ssh/authorized_keys
chown git:git -R /home/git
</code></p>

<p>注意：如果是root用户执行的命令，需要修改权限如下
<code>
chown -R git:git testrepo
</code></p>

<ul>
<li>Client</li>
</ul>


<p><code>bash
git clone git@sevrer_ip:/home/git/testrepo  //克隆repo
</code></p>

<p>具体操作<br/>
<code>bash
cd testrepo                         //进入本地版本库
echo "hello" &gt;&gt; test                //新建测试文件
git add test                        //添加到git缓存
git commit -m "first commit" test   //本地提交
git push -u origin master           //提交给远程服务器
git pull                            //客户端拉取数据
</code></p>

<h2><u>Svn Server with apache &amp;&amp; ldap</u></h2>

<p><code>bash
yum install subversion mod_dav_svn -y
</code></p>

<p>yum安装后会生成subversion.conf并添加相应模块配置
``` bash</p>

<h1>grep LoadModule /etc/httpd/conf.d/subversion.conf</h1>

<p>LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
```</p>

<p>svn创建库<br/>
<code>bash
svnadmin create --fs-type fsfs /var/www/svn
chown apache:apache -R /var/www/svn
</code></p>

<p>设置ldap认证<br/>
``` bash</p>

<h1>grep -vE '<sup>$|<sup>#'</sup></sup> /etc/httpd/conf.d/subversion.conf</h1>

<p>LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
<Location /svn></p>

<pre><code>DAV svn 
SVNPath /var/www/svn
AuthBasicProvider ldap
AuthType Basic
AuthzLDAPAuthoritative off
AuthName "Please provide your windows login credentials to continue."
AuthLDAPURL "ldap://ldap_ip/ou=users,ou=test,dc=intranet,dc=test,dc=com?sAMAccountName" NONE
AuthLDAPBindDN "test@intranet.test.com"
AuthLDAPBindPassword password 
require valid-user
</code></pre>

<p></Location>
```</p>

<p>启动apache<br/>
<code>
service httpd start
</code></p>

<p>浏览器登陆<br/>
<a href="http://svn_ip/svn">http://svn_ip/svn</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修改CentOS/RHEL rsync监听地址]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/11/07/rsync/"/>
    <updated>2013-11-07T10:35:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/11/07/rsync</id>
    <content type="html"><![CDATA[<p>为了安全起见，服务器不对外提供的服务尽量不监听外网地址的，rsync也不例外。由于CentOS/RHEL中rpm安装的rsync为非独立进程，需要依赖xinetd进程。笔者一开始尝试修改rsync的配置文件<code>rsyncd.conf</code>中加入<code>address = 192.168.80.128</code>，重启xinetd服务，发现修改没有生效。</p>

<!--more-->


<p><code>bash
...
tcp        0      0 0.0.0.0:873                 0.0.0.0:*       ...
...
</code></p>

<p>因为CentOS/RHEL是依赖xinetd的，所以我就想到了xinetd配置文件<code>/etc/xinetd.conf</code>，发现选项<code># bind       =</code>，于是修改如下</p>

<p>``` bash
...</p>

<pre><code>bind        = 192.168.80.128    # 此处ip填写主机本地ip即可
</code></pre>

<p>...
```</p>

<p>修改完成保存，重启xinetd程序，修改生效</p>

<p><code>bash
...
tcp        0      0 192.168.80.128:873               0.0.0.0:*                   LISTEN      25967/xinetd
...
</code></p>

<p>当然你也可以直接不依赖xinetd修改监听地址，直接使用命令启动rsync，如下</p>

<p><code>bash
rsync --address=192.168.80.128 --config=/etc/rsyncd.conf --daemon
</code></p>

<p>--EOF--</p>
]]></content>
  </entry>
  
</feed>
