<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: UNIX/Linux | Linux SA Notes By 枯木]]></title>
  <link href="http://kumu-Linux.github.io/blog/categories/unix-slash-linux/atom.xml" rel="self"/>
  <link href="http://kumu-Linux.github.io/"/>
  <updated>2013-09-22T19:19:52+08:00</updated>
  <id>http://kumu-Linux.github.io/</id>
  <author>
    <name><![CDATA[枯木]]></name>
    <email><![CDATA[1988.wulei@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ssh认证代理]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/09/09/ssh-agent/"/>
    <updated>2013-09-09T10:55:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/09/09/ssh-agent</id>
    <content type="html"><![CDATA[<h3>简介</h3>

<p>ssh允许用户把密钥存储在内存中，这就是ssh认证代理[ssh-agent]。认证代理为用户提供了使用RSA密钥而不必随时键入口令字的能力，这对于不必在所有登录、X会话或运行脚本时都要键入口令字提供便利是很有效的。ssh-agent是个长时间持续运行的守护进程（daemon），设计它的唯一目的就是对解密的专用密钥进行高速缓存。ssh包含的内建支持允许它同ssh-agent通信，允许ssh不必每次新连接时都提示您要密码才能获取解密的专用密钥。</p>

<!--more-->


<h3>实例</h3>

<h4>Before ssh-agent</h4>

<p>``` bash</p>

<h1>ssh root@192.168.80.130</h1>

<p>Enter passphrase for key '/root/.ssh/id_rsa':   # 正常输入密码
Last login: Sat Sep  7 12:40:02 2013 from 192.168.80.131
```</p>

<h4>After ssh-agent</h4>

<p>``` bash</p>

<h1>ssh-agent bash</h1>

<h1>ssh-add</h1>

<h1>默认ssh-add添加~/.ssh/id_rsa私钥，按提示输入密码即可，可添加多个密钥</h1>

<h1>如果要加入其它密钥直接 ssh-add 私钥文件 即可</h1>

<p>Enter passphrase for /root/.ssh/id_rsa:
Identity added: /root/.ssh/id_rsa (/root/.ssh/id_rsa)</p>

<h1>ssh-add -l                    # 显示添加密钥添加列表</h1>

<p>2048 4f:a8:76:04:42:90:b4:18:c1:6b:13:06:31:c8:59:bf /root/.ssh/id_rsa (RSA)</p>

<h1>ssh root@192.168.80.130       # 不需要密码登录了</h1>

<p>Last login: Sat Sep  7 12:58:09 2013 from 192.168.80.128
```</p>

<h4>ssh-agent + ForwardAgent</h4>

<p>A->B->C...
``` bash</p>

<h1>ssh root@192.168.80.130</h1>

<p>Last login: Sat Sep  7 14:05:34 2013 from 192.168.80.128</p>

<h1>ssh root@192.168.80.131       # 默认ForwardAgent默认值为no，因此登录到B时再登录C需要密码了</h1>

<p>Enter passphrase for key '/root/.ssh/id_rsa':
```</p>

<p>如果想A->B->C...都不需要密码则可以设置<code>~/.ssh/config</code>如下
``` bash
Host *</p>

<pre><code>ForwardAgent yes
</code></pre>

<p>```</p>

<p><strong>设置之后</strong>
``` bash</p>

<h1>ssh root@192.168.80.130</h1>

<p>Last login: Sat Sep  7 14:06:01 2013 from 192.168.80.128</p>

<h1>ssh root@192.168.80.131       # 没有再次提示输入密码，直接登录</h1>

<p>Last login: Sat Sep  7 14:05:20 2013 from 192.168.80.130
```</p>

<h3>参考和拓展文档</h3>

<ul>
<li><a href="http://blog.hellosa.org/2010/03/07/ssh-agent-secure.html">ssh-agent 的安全隐患</a></li>
<li><a href="http://blog.pkufranky.com/2012/08/ssh-agent-forwarding-guide/">SSH Agent Forwarding原理</a></li>
<li><a href="http://livecipher.blogspot.tw/2013/02/ssh-agent-forwarding.html">SSH key agent forwarding</a></li>
<li><a href="https://help.github.com/articles/using-ssh-agent-forwarding">Using ssh agent forwarding</a></li>
<li><a href="upc.lbl.gov/docs/user/sshagent.shtml">A short ssh-agent tutorial</a></li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rsyslog远程传输的几种方式]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/08/28/rsyslog-remote/"/>
    <updated>2013-08-28T10:51:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/08/28/rsyslog-remote</id>
    <content type="html"><![CDATA[<h3>基本介绍</h3>

<p>Rsyslog是一个syslogd的多线程增强版，<a href="www.rsyslog.com/doc/rsyslog_ng_comparison.html">rsyslog vs. syslog-ng</a> 链接是rsyslog官方和syslog特性和性能上的一些对比，目前大部分Linux发行版本默认也是使用rsyslog记录日志。这里介绍rsyslog远程传输的几种方式，对远程日志传输可以有一个了解。</p>

<!--more-->


<p>rsyslog提供三个远程日志传输方式：</p>

<ul>
<li>UDP: 数据包传输可信度不高</li>
<li>TCP: 数据包传输可信度比较高</li>
<li>RELP: 数据包传输可信度最高，避免数据丢失，比较新的协议，目前应用较少</li>
</ul>


<p>以下为man手册对RELP协议的一个介绍：</p>

<blockquote><p>RELP can be used instead of UDP or plain TCP syslog to  provide  reliable  delivery  of syslog  messages.  Please  note that plain TCP syslog does NOT provide truly reliable delivery, with it messages may be  lost when there is a connection problem or the server shuts down. RELP prevents message loss in hose cases.</p></blockquote>

<p>关于RELP的更进一步了解可以参考 <a href="http://www.rsyslog.com/tag/relp/">Using TLS with RELP</a> <a href="http://www.rsyslog.com/doc/imrelp.html">RELP Input Module</a>  <a href="http://www.rsyslog.com/doc/omrelp.html">RELP Output Module (omrelp)</a></p>

<h3>相关配置</h3>

<blockquote><p>To forward messages to another host via UDP, prepend the hostname with the at sign ("@").  To forward it via plain tcp, prepend two at signs ("@@"). To forward via RELP, prepend the string ":omrelp:" in front of the hostname.</p></blockquote>

<h4>UDP传输</h4>

<h5>Server端配置</h5>

<p>``` bash /etc/rsyslog.conf</p>

<h1>Provides UDP syslog reception</h1>

<p>$ModLoad imudp
$UDPServerRun 514
$AllowedSender UDP, 192.168.80.0/24</p>

<h1>This one is the template to generate the log filename dynamically, depending on the client's IP address.</h1>

<h1>根据客户端的IP单独存放主机日志在不同目录，syslog需要手动创建</h1>

<p>$template Remote,"/var/log/syslog/%fromhost-ip%/%fromhost-ip%_%$YEAR%-%$MONTH%-%$DAY%.log"</p>

<h1>Log all messages to the dynamically formed file.</h1>

<p>:fromhost-ip, !isequal, "127.0.0.1" ?Remote</p>

<h1>排除本地主机IP日志记录，只记录远程主机日志</h1>

<h1>注意此规则需要在其它规则之前，否则配置没有意义，远程主机的日志也会记录到Server的日志文件中</h1>

<p>&amp; ~ # 忽略之前所有的日志，远程主机日志记录完之后不再继续往下记录
```</p>

<p>或者把以上配置单独存放在<code>/etc/rsyslog.d/</code>中的xxx.conf配置文件中，尽量避免修改主配置文件，当然如果要独立文件主配置文件中必须含有以下配置</p>

<p>``` bash</p>

<h1>grep 'rsyslog.d' /etc/rsyslog.conf</h1>

<h1>Include all config files in /etc/rsyslog.d/</h1>

<p>$IncludeConfig /etc/rsyslog.d/*.conf
```</p>

<h5>Client端配置</h5>

<p><code>bash /etc/rsyslog.conf
*.*                     @192.168.80.130
</code></p>

<p>以上配置完成之后<code>/etc/init.d/rsyslog restart</code></p>

<h4>TCP传输</h4>

<p>TCP配置和UDP类似，如下</p>

<h5>Server端配置</h5>

<p>``` bash /etc/rsyslog.conf</p>

<h1>Provides TCP syslog reception</h1>

<p>$ModLoad imtcp
$InputTCPServerRun 514
$AllowedSender TCP, 192.168.80.0/24</p>

<h1>This one is the template to generate the log filename dynamically, depending on the client's IP address.</h1>

<p>$template Remote,"/var/log/syslog/%fromhost-ip%/%fromhost-ip%_%$YEAR%-%$MONTH%-%$DAY%.log"</p>

<h1>Log all messages to the dynamically formed file.</h1>

<p>:fromhost-ip, !isequal, "127.0.0.1" ?Remote
&amp; ~
```</p>

<h5>Client端配置</h5>

<p><code>bash /etc/rsyslog.conf
*.*                     @@192.168.80.130
</code></p>

<p>客户端和服务端重启相关服务即可</p>

<p>关于TCP和UDP的传输方式，rsyslog官方推荐使用TCP传输方式</p>

<blockquote><p>In general, we suggest to use TCP syslog. It is way more reliable than UDP syslog and still pretty fast. The main reason is, that UDP might suffer of message loss. This happens when the syslog server must receive large bursts of messages. If the system buffer for UDP is full, all other messages will be dropped. With TCP, this will not happen. But sometimes it might be good to have a UDP server configured as well. That is, because some devices (like routers) are not able to send TCP syslog by design. In that case, you would need both syslog server types to have everything covered. If you need both syslog server types configured, please make sure they run on proper ports. By default UDP syslog is received on port 514. TCP syslog needs a different port because often the RPC service is using this port as well.</p></blockquote>

<h4>RELP传输</h4>

<p>RELP需要安装<code>rsyslog-relp</code>相应模块</p>

<p>``` bash</p>

<h1>yum install rsyslog-relp -y</h1>

<p>```</p>

<h5>Server端配置</h5>

<p>``` bash /etc/rsyslog.conf
$ModLoad imrelp # 加载相应模块
$InputRELPServerRun 20514 # 监听端口</p>

<h1>This one is the template to generate the log filename dynamically, depending on the client's IP address.</h1>

<p>$template Remote,"/var/log/syslog/%fromhost-ip%/%fromhost-ip%_%$YEAR%-%$MONTH%-%$DAY%.log"</p>

<h1>Log all messages to the dynamically formed file.</h1>

<p>:fromhost-ip, !isequal, "127.0.0.1" ?Remote
```</p>

<h5>Client端配置</h5>

<p><code>bash /etc/rsyslog.conf
$ActionQueueType LinkedList     # use asynchronous processing
$ActionQueueFileName srvrfwd    # set file name, also enables disk mode
$ActionResumeRetryCount -1      # infinite retries on insert failure
$ActionQueueSaveOnShutdown on   # save in-memory data if rsyslog shuts down
*.* :omrelp:192.168.80.130:20514
</code></p>

<p>客户端和服务端重启相关服务即可</p>

<h3>参考和拓展资料</h3>

<ul>
<li><a href="http://www.rsyslog.com/tag/relp/">Using TLS with RELP</a></li>
<li><a href="http://www.rsyslog.com/doc/imrelp.html">RELP Input Module</a></li>
<li><a href="http://www.rsyslog.com/doc/omrelp.html">RELP Output Module (omrelp)</a></li>
<li><a href="http://gertverdemme.nl/sysadm/security/rsyslog_relp_remote_logging">Rsyslog remote logging using RELP</a></li>
<li><a href="http://www.rsyslog.com/tag/udp/">UDP Rsyslog</a></li>
<li><a href="http://www.rsyslog.com/tag/tcp/">TCP Rsyslog</a></li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pssh使用方法]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/08/12/pssh/"/>
    <updated>2013-08-12T14:53:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/08/12/pssh</id>
    <content type="html"><![CDATA[<p>pssh是一个python编写可以在多台服务器上执行命令的工具，同时支持拷贝文件，是同类工具中很出色的，类似pdsh <a href="http://kumu-linux.github.io/blog/2013/06/19/pdsh/">pdsh使用方法</a> 。为方便操作，使用前请在各个服务器上配置好密钥认证访问。项目地址: <a href="https://code.google.com/p/parallel-ssh/">parallel-ssh</a></p>

<!--more -->


<h3>安装</h3>

<p><code>bash
wget http://parallel-ssh.googlecode.com/files/pssh-2.3.1.tar.gz
tar zxvf pssh-2.3.1.tar.gz
cd pssh-2.3.1/
python setup.py install
</code></p>

<h3>pssh相关参数</h3>

<ul>
<li>pssh在多个主机上并行地运行命令

<ul>
<li>-h 执行命令的远程主机列表,文件内容格式[user@]host[:port]

<ul>
<li> 如 test@172.16.10.10:229</li>
</ul>
</li>
<li>-H 执行命令主机，主机格式 user@ip:port</li>
<li>-l 远程机器的用户名</li>
<li>-p 一次最大允许多少连接</li>
<li>-P 执行时输出执行信息</li>
<li>-o 输出内容重定向到一个文件</li>
<li>-e 执行错误重定向到一个文件</li>
<li>-t 设置命令执行超时时间</li>
<li>-A 提示输入密码并且把密码传递给ssh(如果私钥也有密码也用这个参数)</li>
<li>-O 设置ssh一些选项</li>
<li>-x 设置ssh额外的一些参数，可以多个，不同参数间空格分开</li>
<li>-X 同-x,但是只能设置一个参数</li>
<li>-i 显示标准输出和标准错误在每台host执行完毕后</li>
</ul>
</li>
</ul>


<h3>附加工具</h3>

<ul>
<li>pscp 传输文件到多个hosts，类似scp

<ul>
<li>pscp -h hosts.txt -l irb2 foo.txt /home/irb2/foo.txt</li>
</ul>
</li>
<li>pslurp 从多台远程机器拷贝文件到本地</li>
<li>pnuke 并行在远程主机杀进程

<ul>
<li>pnuke -h hosts.txt -l irb2 java</li>
</ul>
</li>
<li>prsync 使用rsync协议从本地计算机同步到远程主机

<ul>
<li>prsync -r -h hosts.txt -l irb2 foo /home/irb2/foo</li>
</ul>
</li>
</ul>


<h3>示例</h3>

<p><code>bash
kumu-opsdev ~ # cat host.txt
root@192.168.230.128
wul@10.0.0.8
</code></p>

<p>推荐使用<code>-i</code>选项输出信息而不是<code>-P</code>选项
<code>bash
kumu-opsdev ~ # pssh -i -h host.txt 'date'
[1] 16:32:38 [SUCCESS] root@192.168.230.128
Mon Aug 12 16:32:38 CST 2013
[2] 16:32:38 [SUCCESS] wul@10.0.0.8
Mon Aug 12 16:32:38 CST 2013
</code></p>

<p><code>-x</code>选项
<code>
kumu-opsdev ~ # pssh -x '-t -t -o StrictHostKeyChecking=no' -i -h host.txt date
[1] 17:20:01 [SUCCESS] root@192.168.230.128
Mon Aug 12 17:20:01 CST 2013
Stderr: Connection to 192.168.230.128 closed.
[2] 17:20:01 [SUCCESS] wul@10.0.0.8
Mon Aug 12 17:20:01 CST 2013
Stderr: Connection to 10.0.0.8 closed.
</code></p>

<p><code>-H</code>选项
<code>
kumu-opsdev ~ # pssh -x '-t -t -o StrictHostKeyChecking=no' -i -H 192.168.230.128 -H wul@10.0.0.8 date
[1] 17:22:58 [SUCCESS] 192.168.230.128
Mon Aug 12 17:22:58 CST 2013
Stderr: Connection to 192.168.230.128 closed.
[2] 17:22:58 [SUCCESS] wul@10.0.0.8
Mon Aug 12 17:22:58 CST 2013
Stderr: Connection to 10.0.0.8 closed.
</code></p>

<h3>参考文档</h3>

<ul>
<li><a href="http://linux.die.net/man/1/pssh">pssh</a></li>
<li><a href="http://www.theether.org/pssh/docs/0.2.3/pssh-HOWTO.html">pssh-howto</a></li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nslookup、host和dig]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/06/19/nslookup-dig-host/"/>
    <updated>2013-06-19T16:55:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/06/19/nslookup-dig-host</id>
    <content type="html"><![CDATA[<p><code>nslookup</code>、<code>host</code>和<code>dig</code>是三个DNS查询工具，以下会分别介绍它们的使用方法。</p>

<!--more-->


<h2>nslookup</h2>

<blockquote><p>nslookup is a tried and true program that has weathered the ages. nslookup has been deprecated and may be removed from future releases. There is not even a man page for this program.</p></blockquote>

<p>因此，这里不过多介绍这个古老的工具了</p>

<h2>host</h2>

<p><code>host</code>命令和<code>dig</code>命令很相像，但是<code>host</code>命令的输出要更简洁，如下示例
``` bash</p>

<pre><code>  # host www.google.com
  www.google.com has address 74.125.135.106
</code></pre>

<p>```</p>

<p><code>host</code>命令只输出给我们<code>dig</code>命令的ANSWER section，相对<code>dig</code>提供的一些不必要的信息来说更简洁快速。也可指定DNS Server来查询，例如我想使用Google DNS<code>8.8.8.8</code>,named可以如下指定
``` bash</p>

<h1>host www.google.com 8.8.8.8</h1>

<p>Using domain server:
Name: 8.8.8.8
Address: 8.8.8.8#53
Aliases:</p>

<p>www.google.com has address 173.194.72.147
```</p>

<p><code>host</code>当然也支持反解析
``` bash</p>

<h1>host 173.194.72.147</h1>

<p>147.72.194.173.in-addr.arpa domain name pointer tf-in-f147.1e100.net.
```</p>

<p>指定查询类型可以使用<code>-t</code>选项</p>

<p>``` bash</p>

<h1>host -t SOA google.com  #查询SOA记录信息</h1>

<p>google.com has SOA record ns1.google.com. dns-admin.google.com. 2013061100 7200 1800 1209600 300
```</p>

<p>查询<code>MX</code>记录
<code>
$ host -t MX google.com
google.com mail is handled by 10 aspmx.l.google.com.
google.com mail is handled by 40 alt3.aspmx.l.google.com.
google.com mail is handled by 20 alt1.aspmx.l.google.com.
google.com mail is handled by 50 alt4.aspmx.l.google.com.
google.com mail is handled by 30 alt2.aspmx.l.google.com.
</code></p>

<p><code>-C</code>对比认证DNS SOA信息
```</p>

<h1>host -C google.com</h1>

<p>Nameserver 216.239.34.10:</p>

<pre><code>    google.com has SOA record ns1.google.com. dns-admin.google.com. 2013061100 7200 1800 1209600 300
</code></pre>

<p>Nameserver 216.239.36.10:</p>

<pre><code>    google.com has SOA record ns1.google.com. dns-admin.google.com. 2013061100 7200 1800 1209600 300
</code></pre>

<p>Nameserver 216.239.32.10:
... ...
```</p>

<p>查询DNS Server软件版本信息,10.10.10.2为DNS Server
``` bash</p>

<h1>host -c CH -t txt version.bind 10.10.10.2</h1>

<p>Using domain server:
Name: 10.10.10.2
Address: 10.10.10.2#53
Aliases:</p>

<p>version.bind descriptive text "9.8.1-P2"
```</p>

<p><strong>host帮助</strong>
``` bash</p>

<h1>host</h1>

<p>Usage: host [-aCdlriTwv] [-c class] [-N ndots] [-t type] [-W time]</p>

<pre><code>        [-R number] [-m flag] hostname [server]
   -a is equivalent to -v -t ANY
   -c specifies query class for non-IN data  搜索非网络数据时要指定要查找的类
   -C compares SOA records on authoritative nameservers
   -d is equivalent to -v
   -l lists all hosts in a domain, using AXFR
   -i IP6.INT reverse lookups
   -N changes the number of dots allowed before root lookup is done
   -r disables recursive processing
   -R specifies number of retries for UDP packets
   -s a SERVFAIL response should stop query
   -t specifies the query type 指定要查询的记录类型
   -T enables TCP/IP mode
   -v enables verbose output  输出更详细的信息
   -w specifies to wait forever for a reply
   -W specifies how long to wait for a reply
   -4 use IPv4 query transport only
   -6 use IPv6 query transport only
   -m set memory debugging flag (trace|record|usage)
</code></pre>

<p>```</p>

<h2>dig</h2>

<p>dig也是一个很强大的命令，相对host来说输出较为繁杂，如下：</p>

<p>``` bash
$ dig www.google.com
... ...</p>

<p>;; ANSWER SECTION:
www.google.com.         297     IN      A       74.125.135.106
www.google.com.         297     IN      A       74.125.135.104
... ...</p>

<p>;; AUTHORITY SECTION:
google.com.             172796  IN      NS      ns3.google.com.
google.com.             172796  IN      NS      ns1.google.com.
google.com.             172796  IN      NS      ns4.google.com.
google.com.             172796  IN      NS      ns2.google.com.</p>

<p>... ...
```</p>

<p>查询<code>MX</code>记录
<code>bash
$ dig google.com MX | grep '^;; ANSWER SECTION:' -A 5
;; ANSWER SECTION:
google.com.             368     IN      MX      50 alt4.aspmx.l.google.com.
google.com.             368     IN      MX      40 alt3.aspmx.l.google.com.
google.com.             368     IN      MX      10 aspmx.l.google.com.
google.com.             368     IN      MX      30 alt2.aspmx.l.google.com.
google.com.             368     IN      MX      20 alt1.aspmx.l.google.com.
</code></p>

<p>查询<code>SOA</code>记录
<code>bash
$ dig google.com SOA | grep '^;; ANSWER SECTION:' -A 1
;; ANSWER SECTION:
google.com.             85539   IN      SOA     ns1.google.com. dns-admin.google.com. 2013061100 7200 1800 1209600 300
</code></p>

<p>指定DNS Server查询
<code>bash
$ dig www.baidu.com @8.8.8.8
... ...
;; ANSWER SECTION:
www.baidu.com.          1024    IN      CNAME   www.a.shifen.com.
www.a.shifen.com.       166     IN      A       119.75.217.56
www.a.shifen.com.       166     IN      A       119.75.218.77
... ...
</code></p>

<p><code>dig</code>查询版本号
<code>bash
$ dig chaos txt version.bind  10.10.10.2 | grep '^;; ANSWER SECTION:' -A 1
;; ANSWER SECTION:
version.bind.           0       CH      TXT     "9.8.1-P2"
</code></p>

<p><code>dig</code>反解析<code>-x</code>
``` bash
$ dig -x 74.125.135.105
;; QUESTION SECTION:
;105.135.125.74.in-addr.arpa.   IN      PTR</p>

<p>;; ANSWER SECTION:
105.135.125.74.in-addr.arpa. 83205 IN   PTR     ni-in-f105.1e100.net.</p>

<p>```</p>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pdsh使用方法]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/06/19/pdsh/"/>
    <updated>2013-06-19T15:26:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/06/19/pdsh</id>
    <content type="html"><![CDATA[<p>PDSH(Parallel Distributed SHell)可并行的执行对目标主机的操作，对于批量执行命令和分发任务有很大的帮助，在使用前需要配置ssh无密码登录，<a href="http://sourceforge.net/projects/pdsh/">点击下载</a></p>

<!--more-->


<h2>pdsh基本用法</h2>

<p><code>bash
 pdsh -h
Usage: pdsh [-options] command ...
-S                return largest of remote command return values
-h                output usage menu and quit                获取帮助
-V                output version information and quit       查看版本
-q                list the option settings and quit         列出pdsh执行的一些信息
-b                disable ^C status feature (batch mode)
-d                enable extra debug information from ^C status
-l user           execute remote commands as user           指定远程使用的用户
-t seconds        set connect timeout (default is 10 sec)   指定超时时间
-u seconds        set command timeout (no default)          类似-t
-f n              use fanout of n nodes                     设置同时连接的目标主机的个数
-w host,host,...  set target node list on command line      指定主机，host可以是主机名也可以是ip
-x host,host,...  set node exclusion list on command line   排除某些或者某个主机
-R name           set rcmd module to name                   指定rcmd的模块名，默认使用ssh
-N                disable hostname: labels on output lines  输出不显示主机名或者ip
-L                list info on all loaded modules and exit  列出pdsh加载的模块信息
-a                target all nodes                          指定所有的节点
-g groupname      target hosts in dsh group "groupname"     指定dsh组名
-X groupname      exclude hosts in dsh group "groupname"    排除组，一般和-a连用
available rcmd modules: exec,xcpu,ssh (default: ssh)        可用的执行命令模块，默认为ssh
</code></p>

<h2>使用实例</h2>

<p><strong>单个主机测试</strong>
<code>
$ pdsh -w 192.168.0.231 -l root uptime
192.168.0.231:  16:16:11 up 32 days, 22:14, ? users,  load average: 0.10, 0.14, 0.16
</code></p>

<p><strong>多个主机测试</strong>
<code>
$ pdsh -w 192.168.0.[231-233] -l root uptime
192.168.0.233:  16:17:05 up 32 days, 22:17, ? users,  load average: 0.13, 0.12, 0.10
192.168.0.232:  16:17:05 up 32 days, 22:17, ? users,  load average: 0.45, 0.34, 0.27
192.168.0.231:  16:17:06 up 32 days, 22:15, ? users,  load average: 0.09, 0.13, 0.15
</code></p>

<p><strong>逗号分隔主机</strong>
<code>
$ pdsh -w 192.168.0.231,192.168.0.234 -l root uptime
192.168.0.234:  16:19:44 up 32 days, 22:19, ? users,  load average: 0.17, 0.21, 0.20
192.168.0.231:  16:19:44 up 32 days, 22:17, ? users,  load average: 0.29, 0.18, 0.16
</code></p>

<p><strong>-x排除某个主机</strong>
<code>
$ pdsh -w 192.168.0.[231-233] -x 192.168.0.232 -l root uptime
192.168.0.233:  16:18:24 up 32 days, 22:19, ? users,  load average: 0.11, 0.12, 0.09
192.168.0.231:  16:18:25 up 32 days, 22:16, ? users,  load average: 0.11, 0.13, 0.15
</code></p>

<p><strong>主机组</strong><br/>
对于-g组，把对应的主机写入到<code>/etc/dsh/group/</code>或<code>~/.dsh/group/</code>目录下的文件中即可，文件名就是对应组名
<code>bash
$ cat ~/.dsh/group/dsh-test
192.168.0.231
192.168.0.232
192.168.0.233
192.168.0.234
</code></p>

<p><code>bash
$ pdsh -g dsh-test -l root uptime
192.168.0.232:  16:21:38 up 32 days, 22:22, ? users,  load average: 0.01, 0.15, 0.21
192.168.0.231:  16:21:38 up 32 days, 22:19, ? users,  load average: 0.17, 0.16, 0.16
192.168.0.234:  16:21:39 up 32 days, 22:21, ? users,  load average: 0.15, 0.19, 0.19
192.168.0.233:  16:21:40 up 32 days, 22:22, ? users,  load average: 0.15, 0.15, 0.10
</code></p>

<p><strong>dshbak格式化输出</strong><br/>
pdsh的缺省输出格式为主机名加该主机的输出，在主机或输出多时会比较混乱，可以采用<code>dshbak</code>做一些格式化，让输出更清晰。
<code>
$ pdsh -g dsh-test -l root 'date'       #查看哪些主机时间不一样，主机一多，可读性不强
192.168.0.232: Wed Jun 19 16:24:40 CST 2013
192.168.0.231: Wed Jun 19 16:24:40 CST 2013
192.168.0.234: Wed Jun 19 16:24:40 CST 2013
192.168.0.233: Wed Jun 19 16:24:40 CST 2013
</code></p>

<p>使用dshbak之后可读性变得好了很多
```</p>

<h2>$ pdsh -g dsh-test -l root 'date' | dshbak -c  </h2>

<h2>192.168.0.[231-232,234]</h2>

<h2>Wed Jun 19 16:24:18 CST 2013</h2>

<h2>192.168.0.233</h2>

<p>Wed Jun 19 16:24:19 CST 2013
```</p>

<p>--EOF--</p>
]]></content>
  </entry>
  
</feed>
