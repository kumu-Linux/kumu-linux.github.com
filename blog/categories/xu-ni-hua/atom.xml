<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 虚拟化 | Linux SA Notes By 枯木]]></title>
  <link href="http://kumu-Linux.github.io/blog/categories/xu-ni-hua/atom.xml" rel="self"/>
  <link href="http://kumu-Linux.github.io/"/>
  <updated>2013-12-11T09:10:11+08:00</updated>
  <id>http://kumu-Linux.github.io/</id>
  <author>
    <name><![CDATA[枯木]]></name>
    <email><![CDATA[1988.wulei@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[qemu-kvm桥接网络]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/12/10/kvm-tap/"/>
    <updated>2013-12-10T22:22:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/12/10/kvm-tap</id>
    <content type="html"><![CDATA[<!--more-->


<h2>手动桥接</h2>

<p>qemu-kvm安装或者启动虚拟系统的时候如果需要和外界通信，那么就要设置网络桥接
<code>bash
/usr/libexec/qemu-kvm -m 1024 \
-drive file=/data/images/CentOS6_4.qcow2,if=virtio \
-net nic,model=virtio -net tap,script=no -nographic -vnc :0
</code></p>

<p>使用<code>-net tap,script=no</code>方式启动之后，系统会生成tapX的虚拟网卡,默认是DOWN状态的
``` bash</p>

<h1>ip link show dev tap0</h1>

<p>37: tap0: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 500</p>

<pre><code>link/ether d2:b0:af:7b:23:0f brd ff:ff:ff:ff:ff:ff
</code></pre>

<p>```</p>

<p>如果想和外界通信，可以手动执行生效，如下所示当前与br0桥接的设备，并没有tap相关的网卡
``` bash</p>

<h1>brctl show br0</h1>

<p>bridge name bridge id       STP enabled interfaces
br0     8000.b8975a626020   no      eth0</p>

<pre><code>                        vnet0
                        vnet1
</code></pre>

<p>```</p>

<p>我们需要把tap0也桥接到br0下以便和外界通信，方法如下
``` bash</p>

<h1>ip link set tap0 up       //使tap0状态变为up</h1>

<h1>brctl addif br0 tap0      //桥接tap0到br0</h1>

<h1>brctl show br0</h1>

<p>bridge name bridge id       STP enabled interfaces
br0     8000.b8975a626020   no      eth0</p>

<pre><code>                        tap0
                        vnet0
                        vnet1
</code></pre>

<p>```</p>

<p><code>brctl delif br0 tap0</code>删除桥接网络，qemu-kvm工具在客户机关闭时会自动解除TAP设备的bridge绑定，所以这一步无需操作</p>

<h2>脚本实现</h2>

<p><code>bash
/usr/libexec/qemu-kvm -m 1024 \
-drive file=/data/images/CentOS6_4.qcow2,if=virtio \
-net nic,model=virtio -net tap,script=/tmp/qemu-ifup.sh -nographic -vnc :0
</code></p>

<p>如上<code>tap,script=/tmp/qemu-ifup.sh</code>指定script网络配置启动前启动脚本，脚本内容如下
``` bash</p>

<h1>cat /tmp/qemu-ifup.sh</h1>

<h1>!/bin/bash</h1>

<h1>桥接网络设备</h1>

<p>switch=br0</p>

<p>if [ -n $1 ]; then          //$1为qemu-kvm传递值，这里是tap</p>

<pre><code>ip link set $1 up
brctl addif ${switch} $1
exit 0
</code></pre>

<p>else
   echo "no interface!"
   exit 1
fi
```
如此，便不需要每次手动添加了</p>

<p>这部分内容的理解主要是 <a href="http://smilejay.com/2012/08/kvm-bridge-networking/">KVM使用网桥模式</a> 这篇文章，顺便推荐此博主的《KVM虚拟化技术：实战与原理解析》一书，对系统的学习KVM很有帮助</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenNebula添加节点]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/11/07/opennubula-node/"/>
    <updated>2013-11-07T15:14:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/11/07/opennubula-node</id>
    <content type="html"><![CDATA[<h3>需求</h3>

<p>The hosts must have a working installation of KVM, that usually requires:</p>

<ul>
<li>CPU with VT extensions</li>
<li>libvirt >= 0.4.0</li>
<li>kvm kernel modules (kvm.ko, kvm-{intel,amd}.ko). Available from kernel 2.6.20 onwards.</li>
<li>the qemu user-land tools</li>
</ul>


<!--more-->


<p>笔者测试所用为VMware Workstation，除本身物理机支持并开启虚拟化外，Workstation也要开启相关配置[ 设置--处理器，查看是否开启 ]</p>

<h3>节点软件安装</h3>

<p>可以参见<a href="http://kumu-linux.github.io/blog/2013/08/22/opennebula-install/">OpenNebula在CentOS6.4安装备忘</a></p>

<p>``` bash</p>

<h1>yum install qemu-kvm qemu-img libvirt ruby \</h1>

<p>libvirt-python python-virtinst libvirt-client</p>

<h1>yum install opennebula-common-4.2.0-1.x86_64.rpm \</h1>

<p>opennebula-node-kvm-4.2.0-1.x86_64.rpm
```</p>

<h3>节点配置</h3>

<h4>启动kvm</h4>

<p>``` bash</p>

<h1>/etc/init.d/libvirtd start</h1>

<p>```</p>

<h4>桥接网络</h4>

<p>``` bash</p>

<h1>yum install bridge-utils -y</h1>

<p>```</p>

<p><strong>桥接实例</strong>:</p>

<p>``` bash</p>

<h1>cat /etc/sysconfig/network-scripts/ifcfg-eth0</h1>

<p>DEVICE=eth0
TYPE=Ethernet
ONBOOT=yes
NAME="System eth0"
BRIDGE="br0"</p>

<h1>cat /etc/sysconfig/network-scripts/ifcfg-br0</h1>

<p>DEVICE="br0"
TYPE="Bridge"  # 注意大小写
BOOTPROTO="static"
IPADDR=192.168.80.131
NETMASK=255.255.255.0
GATEWAY=192.168.80.2
ONBOOT="yes"
DELAY=0
```</p>

<p>修改完毕，重启网络</p>

<h4>相关配置修改</h4>

<p>修改/etc/libvirt/qemu.conf的相关配置：
``` bash</p>

<h1>grep -vE '<sup>($|#)'</sup> /etc/libvirt/qemu.conf</h1>

<p>user  = "oneadmin"
group = "oneadmin"
dynamic_ownership = 0
```</p>

<p>修改/etc/libvirt/libvirtd.conf相关配置：
<code>bash
listen_tcp = 1
listen_tls = 0
mdns_adv = 0
unix_sock_group = "oneadmin"
unix_sock_ro_perms = "0777"
unix_sock_rw_perms = "0777"
auth_unix_ro = "none"
auth_unix_rw = "none"
</code></p>

<p>修改/etc/sysconfig/libvirtd相关配置：
<code>bash
LIBVIRTD_ARGS="--listen"
</code></p>

<p>启动libvirtd服务[安全起见可以只监听内网IP]：
``` bash</p>

<h1>/etc/init.d/libvirtd restart</h1>

<h1>netstat -tulnp | grep libvirtd</h1>

<p>tcp        0      0 0.0.0.0:16509       0.0.0.0:<em>       LISTEN      50818/libvirtd    <br/>
tcp        0      0 :::16509            :::</em>            LISTEN      50818/libvirtd    <br/>
```</p>

<p>修改 /etc/sudoers 文件，最后一行加上：
<code>bash
oneadmin ALL=(root)NOPASSWD:ALL
</code></p>

<p>CentOS系统的sudo选项requiretty是默认打开的，远程执行命令时，ssh默认不会分配tty。没有tty，sudo就无法在获取密码时关闭回显。使用-tt选项强制SSH分配tty（使用两次-tt）。另一方面，sudoers中的Defaults选项requiretty要求只有拥有tty的用户才能使用sudo。可以通过visudo编辑配置文件，禁用这个选项：
``` bash</p>

<h1>Defaults    requiretty</h1>

<p>```</p>

<p>添加<code>oneadmin</code>用户和OpenNebula Server主机ssh公钥认证，使得OpenNebula Server主机<code>oneadmin</code>用户可以使用公钥无密码登陆，关于ssh密钥配置这里不再进一步说明。</p>

<h4>其它配置</h4>

<p>另外OpenNebula的脚本要用到/sbin/brctl，而CentOS的路径是/usr/sbin/brctl，添加软链接：
<code>bash
ln -s /usr/sbin/brctl /sbin/brctl
</code></p>

<p>还要用到/usr/bin/kvm，而CentOS没有链接，需要设置软链接：
<code>bash
ln -s /usr/libexec/qemu-kvm /usr/bin/kvm
</code></p>

<p>最后在Web上添加host主机节点即可，状态显示为<code>on</code>则表示添加成功。</p>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenNebula KVM磁盘热插拔]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/09/25/kvm-disk-hotplug/"/>
    <updated>2013-09-25T15:22:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/09/25/kvm-disk-hotplug</id>
    <content type="html"><![CDATA[<p>KVM支持以下两种磁盘类型的热插拔：</p>

<ul>
<li>sd: SCSI (default).</li>
<li>vd: virtio.</li>
</ul>


<p>KVM虚拟机需要开启acpi才支持磁盘的热插拔，使用OpenNebula安装虚拟机的时候需要设置如下选项：</p>

<ul>
<li>FEATURES = [ acpi="yes" ]</li>
</ul>


<!--more-->


<h3>virtio磁盘热插拔</h3>

<p>虚拟机加载acpiphp驱动</p>

<p>``` bash</p>

<h1>modprobe acpiphp  # 加载驱动</h1>

<h1>fdisk -l</h1>

<p>Disk /dev/vda: 32.2 GB, 32212254720 bytes
255 heads, 63 sectors/track, 3916 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes</p>

<p>   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *           1          13      104391   83  Linux
/dev/vda2              14        3916    31350847+  8e  Linux LVM
```</p>

<p>选择需要添加磁盘的虚拟机- [ Disks &amp; Hotplugging ] ，配置完成之后选择 Attach 挂载使用</p>

<center><img src="http://kumu-Linux.github.io/images/OpenNebula/OpenNebula_disk1.jpg" width="500"></center>


<p>Device Prefix选择sd表示scsi磁盘，如果是vd则是vitio类型磁盘。选择Attach之后，刷新页面就会看到新建的磁盘。</p>

<center><img src="http://kumu-Linux.github.io/images/OpenNebula/OpenNebula_disk2.jpg" width="500"></center>


<p>此时查看vda磁盘是否生效
``` bash</p>

<h1>fdisk -l          # 查看磁盘识别</h1>

<p>...</p>

<p>Disk /dev/vdb: 1048 MB, 1048576000 bytes
16 heads, 63 sectors/track, 2031 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes</p>

<p>Disk /dev/vdb doesn't contain a valid partition table
```</p>

<h3>scsi磁盘热插拔</h3>

<p>虚拟机加载acpiphp驱动</p>

<p>``` bash</p>

<h1>modprobe acpiphp  # 加载驱动</h1>

<p>```</p>

<p>选择需要添加磁盘的虚拟机- [ Disks &amp; Hotplugging ] ，配置完成之后选择 Attach挂载使用</p>

<center><img src="http://kumu-Linux.github.io/images/OpenNebula/OpenNebula_disk3.jpg" width="500"></center>


<p>如下即可看到新添加的磁盘
``` bash</p>

<h1>fdisk -l</h1>

<p>...</p>

<p>Disk /dev/sda: 1048 MB, 1048576000 bytes
33 heads, 61 sectors/track, 1017 cylinders
Units = cylinders of 2013 * 512 = 1030656 bytes</p>

<p>Disk /dev/sda doesn't contain a valid partition table
```</p>

<p>如果未识别scsi磁盘，执行如下命令，使得KVM虚拟机识别
``` bash</p>

<h1>echo '- - -' > /sys/class/scsi_host/host0/scan</h1>

<h1>fdisk -l</h1>

<p>...
Disk /dev/sdb: 1048 MB, 1048576000 bytes
33 heads, 61 sectors/track, 1017 cylinders
Units = cylinders of 2013 * 512 = 1030656 bytes</p>

<p>Disk /dev/sdb doesn't contain a valid partition table
```</p>

<h3>参考文档</h3>

<ul>
<li><a href="http://opennebula.org/documentation:rel4.2:kvmg">KVM Driver 4.2</a></li>
<li><a href="http://serverfault.com/questions/453456/adding-virtio-block-devices-at-runtime-in-libvirt-kvm">Adding Virtio block devices at runtime in Libvirt KVM</a></li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenNebula Windows Server镜像制作]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/09/22/opennebula-win/"/>
    <updated>2013-09-22T11:01:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/09/22/opennebula-win</id>
    <content type="html"><![CDATA[<p>Windows镜像制作的方法和Linux其实类似，主要注意的是，Windows需要安装virtio设备驱动。以下主要介绍驱动的安装方法，其它类似镜像导入和模板制作都和Linux方法一样。</p>

<h3>创建虚拟机镜像文件</h3>

<p>``` bash</p>

<h1>qemu-img create -f qcow2 win_2008.qcow2 50G</h1>

<p>```</p>

<!--more-->


<h3>安装虚拟机</h3>

<p>网卡推荐使用e1000，磁盘类型使用virtio。使用virtio需要安装virtio设备驱动，否则默认是不能识别virtio设备的。</p>

<h4>下载fedora项目组最新的virtio驱动iso</h4>

<ul>
<li><a href="http://alt.fedoraproject.org/pub/alt/virtio-win/latest/images/bin/">virtio官网地址</a> 目前的提供virtio最新驱动iso为 <a href="http://alt.fedoraproject.org/pub/alt/virtio-win/latest/images/bin/virtio-win-0.1-65.iso">virtio-win-0.1-65.iso</a> ，下载之后使用如下方式安装</li>
</ul>


<p>``` bash</p>

<h1>kvm -m 2048 -cdrom cn_windows_server_2008_r2.iso \</h1>

<p>-drive file=/data/virtio-win-0.1-65.iso,media=cdrom \
-drive file=win_2008.qcow2,if=virtio \
-net nic,model=e1000 -net tap,ifname=tap0,script=no \
-boot d -nographic -vnc :0
```</p>

<p>客户端通过VNC连接，启动之后virtio的硬盘是不能被识别的，如下图</p>

<center><img src="http://kumu-Linux.github.io/images/OpenNebula/OpenNebula_win1.jpg" width="500" /></center>




<p></p>


<p>此时，需要安装virtio驱动，点击加载驱动程序，Windows Server 2008对应win7版本</p>

<center><img src="http://kumu-Linux.github.io/images/OpenNebula/OpenNebula_win2.jpg" width="500" /></center>


<p></p>


<p>选择之后，按提示操作安装，安装完之后就会识别之前建立的磁盘</p>

<center><img src="http://kumu-Linux.github.io/images/OpenNebula/OpenNebula_win3.jpg" width="500" /></center>


<p></p>


<p>磁盘识别之后就可以之后的完整系统安装，关于Windows Server 2008的安装步骤这里不再赘述。</p>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS6.4 X86_64 kvm+PXE备忘]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/08/22/kvm/"/>
    <updated>2013-08-22T13:10:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/08/22/kvm</id>
    <content type="html"><![CDATA[<h3>Install 安装</h3>

<p>``` bash</p>

<h1>yum install qemu-kvm qemu-img</h1>

<h1>使用kvm至少要安装的包，一个提供用户级别kvm模拟器，一个提供磁盘镜像的管理</h1>

<h1>安装虚拟化管理的相关工具</h1>

<h1>yum install virt-manager libvirt \</h1>

<p>libvirt-python python-virtinst libvirt-client
```</p>

<p>也可以yum groupinstall虚拟化组件，具体可参考<a href="https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Host_Configuration_and_Guest_Installation_Guide/sect-Virtualization_Host_Configuration_and_Guest_Installation_Guide-Host_Installation-Installing_KVM_packages_on_an_existing_Red_Hat_Enterprise_Linux_system.html">Redhat官方文档</a></p>

<!--more-->


<ul>
<li>KVM 管理工具

<ul>
<li>kvm 内核模块 &lt;- qemu 管理工具 (可用性低)</li>
<li>qemu 是开源虚拟化软件, 虚拟不同 CPU 架构, 可以 x86 虚拟 power cpu</li>
<li>libvirt, virsh, virt-manager (redhat 的辅助工具)</li>
<li>libvirt api 提供管理接口工具</li>
<li>virt-manager 调用 libvirt 工具</li>
</ul>
</li>
</ul>


<p></p>


<ul>
<li>ibvirt接口

<ul>
<li>virsh 命令行工具</li>
<li>virt-manager 图形工具</li>
<li>RHEV-M (redhat专用收费软件)</li>
</ul>
</li>
</ul>


<p></p>


<ul>
<li>支持三种虚拟设备

<ul>
<li>Emulated software devices 仿真设备 ->  南北桥, USB, PS/2 ISA PCI</li>
<li>Para-virtualized devices  -> 时钟, 网络, 串口</li>
<li>Physically shared devices --> 光纤设备</li>
</ul>
</li>
</ul>


<p>安装完之后就可以启动kvm了</p>

<p>``` bash</p>

<h1>/etc/init.d/libvirtd start</h1>

<p>```</p>

<h4>桥接网络</h4>

<p>``` bash</p>

<h1>yum install bridge-utils -y</h1>

<p>```</p>

<p>桥接实例:
``` bash</p>

<h1>cat /etc/sysconfig/network-scripts/ifcfg-eth0</h1>

<p>DEVICE=eth0
TYPE=Ethernet
ONBOOT=yes
NAME="System eth0"
BRIDGE="br0"</p>

<h1>cat /etc/sysconfig/network-scripts/ifcfg-br0</h1>

<p>DEVICE="br0"
TYPE="Bridge"  # 注意大小写
BOOTPROTO="static"
IPADDR=192.168.80.131
NETMASK=255.255.255.0
GATEWAY=192.168.80.2
ONBOOT="yes"
DELAY=0
```</p>

<p>具体可参考: <a href="http://www.cyberciti.biz/faq/rhel-linux-kvm-virtualization-bridged-networking-with-libvirt/">CentOS / Redhat: KVM Bridged Network Configuration</a></p>

<h3>构建无人值守，实现KVM PXE安装</h3>

<h4>安装相关软件</h4>

<p>``` bash</p>

<h1>yum install tftp-server syslinux dhcp vsftpd -y</h1>

<p>```</p>

<h5>dhcp</h5>

<p><strong>dhcp</strong> example:</p>

<p>``` bash dhcp</p>

<h1>cat /etc/dhcp/dhcpd.conf</h1>

<p>subnet 192.168.80.0 netmask 255.255.255.0 {</p>

<pre><code>range 192.168.80.10 192.168.80.100;
default-lease-time 600;
max-lease-time 7200;
next-server 192.168.80.131; # PXE Server地址
filename "pxelinux.0";      # 引导文件名
</code></pre>

<p>}</p>

<h1>/etc/init.d/dhcpd restart</h1>

<p>```</p>

<h4>tftp</h4>

<p><strong>tftp</strong> example:</p>

<p>``` bash tftp</p>

<h1>cat /etc/xinetd.d/tftp</h1>

<p>service tftp
{</p>

<pre><code>socket_type     = dgram
protocol        = udp
wait            = yes
user            = root
server          = /usr/sbin/in.tftpd
server_args     = -s /var/lib/tftpboot
disable         = no # 默认yes，改为no即可
per_source      = 11
cps             = 100 2
flags           = IPv4
</code></pre>

<p>}</p>

<h1>/etc/init.d/xinetd restart</h1>

<p>```</p>

<h4>vsftpd</h4>

<p>新建/var/ftp/centos目录，把CentOS光盘镜像挂载至/var/ftp/centos下</p>

<p>``` bash</p>

<h1>mkdir /var/ftp/centos</h1>

<h1>mount /dev/cdrom /var/ftp/centos # 挂载镜像使用-o loop</h1>

<h1>/etc/init.d/vsftpd restart</h1>

<p>```</p>

<h4>无人值守</h4>

<p>``` bash</p>

<h1>mkdir /var/lib/tftpboot/CentOS6</h1>

<h1>cp /var/ftp/centos/images/pxeboot/{initrd.img,vmlinuz} /var/lib/tftpboot/CentOS6</h1>

<h1>cp /var/ftp/centos/isolinux/{boot.msg,vesamenu.c32} /var/lib/tftpboot/</h1>

<h1>cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/</h1>

<h1>mkdir /var/ftp/tftpboot/pxelinux.cfg</h1>

<h1>cp /var/ftp/centos/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default</h1>

<p>```</p>

<p>``` bash tftpboot目录树结构</p>

<h1>tree /var/lib/tftpboot/</h1>

<p>/var/lib/tftpboot/
├── boot.msg
├── CentOS6
│   ├── initrd.img
│   └── vmlinuz
├── pxelinux.0
├── pxelinux.cfg
│   └── default
└── vesamenu.c32</p>

<p>2 directories, 6 files
```</p>

<p><strong>pxelinux.cfg/default</strong> example:</p>

<p>``` bash pxe default</p>

<h1>cat /var/lib/tftpboot/pxelinux.cfg/default</h1>

<h1>default CentOS6_PXE # 默认启动'default CentOS6_PXE'标记的内核</h1>

<p>default vesamenu.c32  # 菜单选项
timeout 100 # 单位是1/10s</p>

<h1>prompt 1  # 为 '0' 时则不提示'boot: '，将会直接启动 'default' 参数中指定的内容</h1>

<p>display boot.msg    # 启动时显示</p>

<h1>menu background splash.jpg    # 菜单背景等</h1>

<p>menu title Welcome to CentOS 6.4!
menu color border 0 #ffffffff #00000000
menu color sel 7 #ffffffff #ff000000
menu color title 0 #ffffffff #00000000
menu color tabmsg 0 #ffffffff #00000000
menu color unsel 0 #ffffffff #00000000
menu color hotsel 0 #ff000000 #ffffffff
menu color hotkey 7 #ffffffff #ff000000
menu color scrollbar 0 #ffffffff #00000000</p>

<p>label CentOS6_PXE
  menu label ^PXE Install CentOS KVM
  kernel /CentOS6/vmlinuz
  append ks=ftp://192.168.80.131/ks.cfg initrd=/CentOS6/initrd.img
label rescue
  menu label ^Rescue installed system
  kernel /CentOS6/vmlinuz
  append initrd=/CentOS6/initrd.img rescue
```</p>

<p>关于PXE的进一步细节可以参考<a href="http://www.syslinux.org/wiki/index.php/PXELINUX">pxelinux官方文档</a></p>

<p><strong>ks.cfg</strong> example:</p>

<p>``` bash ks.cfg</p>

<h1>cat /var/ftp/ks.cfg</h1>

<h1>System authorization information</h1>

<p>auth  --useshadow  --enablemd5</p>

<h1>System bootloader configuration</h1>

<p>bootloader --location=mbr</p>

<h1>Clear the Master Boot Record</h1>

<p>zerombr</p>

<h1>Partition clearing information</h1>

<p>clearpart --all --initlabel</p>

<h1>Use text mode install</h1>

<p>text</p>

<h1>Firewall configuration</h1>

<p>firewall --disabled
skipx</p>

<h1>Run the Setup Agent on first boot</h1>

<p>firstboot --disable</p>

<h1>System keyboard</h1>

<p>keyboard us</p>

<h1>System language</h1>

<p>lang en_US</p>

<h1>Installation logging level</h1>

<p>logging --level=info</p>

<h1>Use network installation</h1>

<p>url --url=ftp://192.168.80.131/centos</p>

<h1>Network information</h1>

<p>network --bootproto=dhcp --device=eth0 --onboot=on</p>

<h1>Reboot after installation</h1>

<p>reboot</p>

<h1>Root password</h1>

<p>rootpw --iscrypted $1$duSkJ1$1P5qGnqUGn3S1MTTFiPJY.</p>

<h1>SELinux configuration</h1>

<p>selinux --disabled</p>

<h1>System timezone</h1>

<p>timezone  Asia/Shanghai</p>

<h1>Install OS instead of upgrade</h1>

<p>install</p>

<h1>Disk partitioning information</h1>

<p>part /boot --asprimary --bytes-per-inode=4096 --fstype="ext3" --size=100
part / --bytes-per-inode=4096 --fstype="ext3" --size=5000
part swap --bytes-per-inode=4096 --fstype="swap" --size=512</p>

<p>%packages --nobase
@core
@Development tools
acpid   # 如果不安装acpid服务，virsh shutdown virtual_name 命令会失效
vim
wget
lsof
%end
```</p>

<p>如果最小化安装则软件包选择如下：</p>

<p><code>bash Minimal install
%packages --nobase
@core
</code></p>

<p>关于kickstart的更进一步了解可参考红帽官档<a href="https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Installation_Guide/s1-kickstart2-options.html">Kickstart Options</a> <a href="https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Host_Configuration_and_Guest_Installation_Guide/sect-Virtualization_Host_Configuration_and_Guest_Installation_Guide-Guest_Installation-Installing_guests_with_PXE.html">Installing guest virtual machines with PXE</a></p>

<h3>PXE 安装KVM虚拟机</h3>

<p>如果要开启--graphics vnc选项，则需要修改vnc监听端口，默认监听的是127.0.0.1，修改为0.0.0.0即可
``` bash</p>

<h1>grep '<sup>vnc_listen'</sup> /etc/libvirt/qemu.conf</h1>

<p>vnc_listen = "0.0.0.0"</p>

<h1>/etc/init.d/libvirtd restart</h1>

<p>```
man手册关于vnc端口介绍摘录：</p>

<pre><code>Address to listen on for VNC/Spice connections. Default is typically 127.0.0.1   
(localhost only), but some hypervisors allow changing this globally     
(for example, the qemu driver default can be changed   in /etc/libvirt/qemu.conf).   
Use 0.0.0.0 to allow access from other machines. This is use by ’vnc’ and ’spice.  
</code></pre>

<h4>安装实例：</h4>

<h5>通过location方式结合Kickstart安装</h5>

<ul>
<li>--extra-args指定ks相关选项，并且指定console类型使得virsh console可以连接操作，也可指定客户机IP、网关、DNS等，无需DHCP：</li>
</ul>


<p>``` bash</p>

<h1>virt-install --name centos --ram=1024 --vcpus=1 --os-type=linux --os-variant=rhel6 \</h1>

<p>--network bridge:br0 --disk path=/var/lib/libvirt/images/centos6-machine1.img,size=10 \
--location ftp://192.168.80.131/centos/ --extra-args "ks=ftp://192.168.80.131/ks.cfg \
ksdevice=eth0 ip=192.168.80.150  netmask=255.255.255.0 console=ttyS0"
```</p>

<h5>PXE方式安装</h5>

<p>``` bash</p>

<h1>virt-install --connect qemu:///system --network=bridge:br0 \</h1>

<p>--pxe --name rhel6-machine1 --ram=1024 --vcpus=1 \
--os-type=linux --os-variant=rhel6 --disk \
path=/var/lib/libvirt/images/rhel6-machine1.img,size=10
```</p>

<p><strong>注意</strong>: 如果需要指定console，--pxe是不支持--extra-args额外选项的，所以需要在pxe <code>default</code> 文件添加相关内容[SERIAL和console]，如下example</p>

<p>``` bash
SERIAL 0 115200
label CentOS6_PXE</p>

<pre><code>menu label ^PXE Install CentOS KVM
kernel /CentOS6/vmlinuz
append ks=ftp://192.168.80.131/ks.cfg initrd=/CentOS6/initrd.img console=tty0 console=ttyS0,115200
</code></pre>

<p>```</p>

<h5>本地安装：</h5>

<p>``` bash</p>

<h1>virt-install --name centos --ram=1024 --vcpus=1 --os-type=linux \</h1>

<p>--os-variant=rhel6 --location /mnt/ --network bridge:br0 \
--disk path=/var/lib/libvirt/images/rhel6.img,size=10 --extra-args "console=ttyS0"
```</p>

<p>关于KVM的Guest安装方式，virt-install man手册中也有很多实例，这里不一一介绍。</p>

<p>开启--graphics vnc选项可在Windows下下载vncviewer客户端，输入对应IP和端口即可[ 笔者个人还是习惯通过console连接安装，不开启vnc选项 ]，如下</p>

<p>``` bash 查看对应端口</p>

<h1>netstat -tulnp | grep kvm</h1>

<p>tcp        0      0 0.0.0.0:5900                0.0.0.0:<em>                   LISTEN      55762/qemu-kvm    <br/>
tcp        0      0 0.0.0.0:5901                0.0.0.0:</em>                   LISTEN      56656/qemu-kvm  <br/>
```</p>

<p>连接对应端口<br/>
<img src="http://kumu-Linux.github.io/images/vnc1.png" width="500"></p>

<p></p>


<p>连接之后,就可以正常安装了</p>

<p><img src="http://kumu-Linux.github.io/images/vnc2.png" width="500"></p>

<h3>virsh 操作命令</h3>

<p>这里只介绍一些常用的virsh使用方法，具体的命令可以参看virsh的man手册介绍或者参考红帽官方文档<a href="https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Virtualization/chap-Virtualization-Managing_guests_with_virsh.html">Managing guests with virsh</a></p>

<p>默认只输入virsh命令会进入virsh的终端：如下，help可以获取命令帮助</p>

<p>``` bash</p>

<h1>virsh</h1>

<p>Welcome to virsh, the virtualization interactive terminal.</p>

<p>Type:  'help' for help with commands</p>

<pre><code>   'quit' to quit
</code></pre>

<p>virsh #
```</p>

<p>virsh简单操作</p>

<p>``` bash
virsh # list    # 显示运行或者暂停的Guest</p>

<h2> Id    Name                           State</h2>

<p> 28    centos6_1                      running</p>

<p>virsh # list --all  # 显示所有的Guest，包括状态为shut off的</p>

<h2> Id    Name                           State</h2>

<p> 28    centos6_1                      running
 -     centos                         shut off</p>

<p>virsh # console centos6_1   # console方式连接Guest
Connected to domain centos6_1
Escape character is ^]      # 使用Ctrl+]即可退出</p>

<p>CentOS release 6.4 (Final)
Kernel 2.6.32-358.el6.x86_64 on an x86_64</p>

<p>localhost.localdomain login:
virsh # start centos        # 开启某个Guest
Domain centos started</p>

<p>virsh # list</p>

<h2> Id    Name                           State</h2>

<p> 28    centos6_1                      running
 32    centos                         running
virsh # shutdown centos</p>

<h1>关闭某个Guest，这里一定要注意，如果Guest没有安装运行acpid服务，</h1>

<h1>则此方式失效，可以kill强制关闭，或者console/ssh连接执行关闭</h1>

<p>Domain centos is being shutdown
```</p>

<p>删除某个Guest，一般需要两步走，对于正在运行的Guest则需要先关闭再继续两步走[也可以直接virsh destroy virtual_name], 这里就演示三步：
<code>bash
virsh destroy guest_name
virsh undefine guest_name
rm -rf guest_img  # 删除虚拟存储
</code></p>

<p>挂起主机
``` bash
virsh # list</p>

<h2> Id    Name                           State</h2>

<p> 28    centos6_1                      running</p>

<p>virsh # suspend centos6_1   # 挂起主机
Domain centos6_1 suspended</p>

<p>virsh # list</p>

<h2> Id    Name                           State</h2>

<p> 28    centos6_1                      paused</p>

<p>virsh # resume centos6_1    # 把主机从挂起状态切换至运行状态
Domain centos6_1 resumed</p>

<p>virsh # list</p>

<h2> Id    Name                           State</h2>

<p> 28    centos6_1                      running</p>

<p>virsh #
```</p>

<h4>virt-clone 克隆Guest</h4>

<p>``` bash</p>

<h1>virt-clone --connect=qemu:///system --original=centos6_1 \</h1>

<p>--name=centos6_2 -f /var/lib/libvirt/images/centos6_2.img
ERROR    Domain with devices to clone must be paused or shutoff.</p>

<h1>virsh suspend centos6_1</h1>

<p>Domain centos6_1 suspended</p>

<h1>virsh list</h1>

<h2> Id    Name                           State</h2>

<p> 28    centos6_1                      paused</p>

<h1>virt-clone --connect=qemu:///system --original=centos6_1 \</h1>

<p>--name=centos6_2 -f /var/lib/libvirt/images/centos6_2.img
Allocating 'centos6_2.img'           1% [-              ] 9.0 MB/s | 112 MB     18:44 ETA
```</p>

<h3>参考和拓展资料</h3>

<ul>
<li><a href="http://www.joshbolling.com/blog/2013/01/automate-rhel-based-os-deployments-with-pxe-boot-and-kickstart/">Automate RHEL Based OS Deployments with PXE Boot and Kickstart</a></li>
<li><a href="http://www.linuxquestions.org/questions/linux-networking-3/centos-and-and-serial-console-login-894380/">Centos&amp; and serial console login</a></li>
<li><a href="http://zhumeng8337797.blog.163.com/blog/static/1007689142011715111317513/">kvm virsh console</a></li>
<li><a href="http://docs.fedoraproject.org/zh-CN/Fedora/12/html/Virtualization_Guide/chap-Virtualization_Guide-KVM_live_migration.html">KVM 实时迁移</a></li>
<li><a href="http://blog.csdn.net/signmem/article/details/7489135">rhel6 kvm备忘</a></li>
</ul>


<p>自己之前的两篇挫文： <a href="http://blog.csdn.net/kumu_linux/article/details/8263987">KVM在线迁移(动态迁移)</a> <a href="http://blog.csdn.net/kumu_linux/article/details/8263326">RHEL6 KVM安装备忘</a></p>

<p>--EOF--</p>
]]></content>
  </entry>
  
</feed>
