<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 虚拟化 | OPS Notes By 枯木]]></title>
  <link href="http://kumu-Linux.github.io/blog/categories/xu-ni-hua/atom.xml" rel="self"/>
  <link href="http://kumu-Linux.github.io/"/>
  <updated>2014-06-23T18:02:04+08:00</updated>
  <id>http://kumu-Linux.github.io/</id>
  <author>
    <name><![CDATA[枯木]]></name>
    <email><![CDATA[1988.wulei@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用pipework桥接docker]]></title>
    <link href="http://kumu-Linux.github.io/blog/2014/06/04/docker-pipework/"/>
    <updated>2014-06-04T17:24:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2014/06/04/docker-pipework</id>
    <content type="html"><![CDATA[<p>docker创建的时候，默认是接入docker0，只能单主机进行工作，但是在生产环境中往往不同主机的docker也是需要通信的，所以这里要借助另外一个工具，那就是pipework。</p>

<!--more-->


<h3>安装pipework</h3>

<p><code>bash
$ git clone https://github.com/jpetazzo/pipework.git
$ sudo cp -rp pipework/pipework /usr/local/bin/
</code></p>

<h3>安装相应依赖软件</h3>

<p><code>bash
$ sudo apt-get install apring bridge-utils -y
</code></p>

<h3>桥接网络</h3>

<p>Ubuntu14.04</p>

<p>``` bash</p>

<h1>cat /etc/network/interfaces</h1>

<p>auto lo
iface lo inet loopback</p>

<p>auto eth0
iface eth0 inet manual</p>

<p>auto br0
iface br0 inet static
address 192.168.0.219
netmask 255.255.255.0
gateway 192.168.0.254
bridge_ports eth0
bridge_stp off
bridge_fd 0
bridge_maxwait 0
dns-nameservers 192.168.0.254
```</p>

<h3>启动br0，使桥接生效</h3>

<p>``` bash</p>

<h1>ifup br0</h1>

<h1>Bash=$(docker run -i -d -t 192.168.0.219:5000/ubuntu:14.04 /bin/bash)</h1>

<h1>pipework br0 $Bash 192.168.0.223/24</h1>

<h1>给指定容器添加虚拟网卡并桥接到br0，如此不同主机间的docker便可以通过br0通信了</h1>

<p>```</p>

<h3>拓展</h3>

<p>关于进一步的内容[vlan| Open vSwitch | etc..]可以参考以下两篇文章：</p>

<ul>
<li><a href="https://github.com/jpetazzo/pipework/blob/master/README.md">pipework readme</a></li>
<li><a href="http://peerxu.github.io/blog/2014/04/07/docker-with-openvswitch.html">pipework-docker网络增强工具</a></li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[构建docker私有库]]></title>
    <link href="http://kumu-Linux.github.io/blog/2014/06/04/docker-registry/"/>
    <updated>2014-06-04T17:08:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2014/06/04/docker-registry</id>
    <content type="html"><![CDATA[<p>为方便管理，我们需要对官方的镜像做一些定制，我们可以构建私有的<code>docker registry</code></p>

<!--more-->


<h3>快速构建</h3>

<p>The fastest way to get running:</p>

<ul>
<li>install docker：<code>apt-get install docker.io</code></li>
<li>run the registry: <code>docker run -p 5000:5000 registry</code></li>
</ul>


<p>That will use the official image from the Docker index.[因为国内被墙的原因，速度比较慢，推荐第二种方式]</p>

<h3>传统构建方式</h3>

<p><code>bash
$ sudo apt-get install build-essential python-dev libevent-dev python-pip liblzma-dev
$ git clone https://github.com/dotcloud/docker-registry.git
$ cd docker-registry/
$ cp config/config_sample.yml config/config.yml
$ mkdir /data/registry -p
$ pip install .
</code></p>

<h4>启动</h4>

<p><code>bash
$ sudo gunicorn --access-logfile - --debug -k gevent -b 0.0.0.0:5000 \
-w 1 docker_registry.wsgi:application
</code></p>

<p>生产环境可以通过如supervisord创建8个workers，或者通过nginx和apache来管理，具体可以参考<a href="https://github.com/dotcloud/docker-registry">docker-registry readme</a>。</p>

<p><code>bash
$ sudo gunicorn -k gevent --max-requests 100 --graceful-timeout 3600 \
-t 3600 -b localhost:5000 -w 8 docker_registry.wsgi:application
</code></p>

<h4>提交指定容器到私有库</h4>

<p><code>bash
$ docker tag 74fe38d11401 192.168.0.219:5000/ubuntu:12.04
$ docker push 192.168.0.219:5000/ubuntu
</code></p>

<h3>参考</h3>

<ul>
<li><a href="https://github.com/dotcloud/docker-registry">docker-registry readme</a></li>
<li><a href="http://blog.docker.io/2013/07/how-to-use-your-own-registry/">How to use your own Registry</a></li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开始docker]]></title>
    <link href="http://kumu-Linux.github.io/blog/2014/06/04/docker-install-index/"/>
    <updated>2014-06-04T17:03:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2014/06/04/docker-install-index</id>
    <content type="html"><![CDATA[<p>Dokcer的基本原理这里不作介绍，网上已经说的很清楚了，这里就不废话了，可以参考以下几篇文章的介绍。</p>

<ul>
<li><a href="http://tiewei.github.io/cloud/Docker-Getting-Start/">Docker Getting Start: Related Knowledge </a></li>
<li><a href="http://code.csdn.net/news/2819773">谁是容器中的“战斗机”？Docker与Chef、LXC等容器对比</a></li>
<li><a href="http://www.infoq.com/cn/articles/docker-containers">Docker：利用Linux容器实现可移植的应用部署</a></li>
</ul>


<!--more-->


<h2>Docker install</h2>

<p>Docker的安装非常简单，这里只介绍Ubuntu 14.04的安装，其他发行版本的安装可以参考官网手册。</p>

<p><code>bash
$ sudo apt-get update
$ sudo apt-get install docker.io
$ sudo ln -sf /usr/bin/docker.io /usr/local/bin/docker
</code></p>

<p>获取当前docker版本</p>

<p><code>bash
$ sudo docker version
Client version: 0.9.1
Go version (client): go1.2.1
Git commit (client): 3600720
Server version: 0.9.1
Git commit (server): 3600720
Go version (server): go1.2.1
Last stable version: 0.11.1, please update docker
</code></p>

<ul>
<li><a href="http://docs.docker.io/installation/ubuntulinux/">Docker install on ubuntu</a></li>
</ul>


<h2>Docker images</h2>

<ul>
<li><a href="https://index.docker.io/">Docker index</a> Docker镜像首页，包括官方镜像和其它公开镜像</li>
</ul>


<h3>Search index images</h3>

<p><code>bash
$ sudo docker search ubuntu
</code></p>

<h3>Pull images</h3>

<p><code>bash
$ sudo docker pull ubuntu # remote index 获取ubuntu官方镜像
$ sudo docker images # 查看当前镜像列表
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              13.10               5e019ab7bf6d        3 weeks ago         180 MB
ubuntu              saucy               5e019ab7bf6d        3 weeks ago         180 MB
ubuntu              12.04               74fe38d11401        3 weeks ago         209.6 MB
... ...
</code></p>

<p>Docker index被墙？[FUCK GFW!!! %&amp;$#&amp;...]，可绑定host解决，亲测可用，不过可能还是比较慢。</p>

<p>``` bash</p>

<h1>加入以下内容到/etc/hosts下就可以了</h1>

<p>54.234.135.251  get.docker.io
54.234.135.251  cdn-registry-1.docker.io
```</p>

<h3>Running an interactive shell</h3>

<p><code>bash
$ sudo docker run -i -t ubuntu:14.04 /bin/bash
</code></p>

<ul>
<li>ubuntu会有多个版本，通过指定tag来启动特定的版本[image]:[tag]</li>
</ul>


<p><code>bash
$ sudo docker ps # 查看当前运行的容器, ps -a列出当前系统所有的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
6c9129e9df10        ubuntu:14.04        /bin/bash           6 minutes ago       Up 6 minutes                            cranky_babbage
</code></p>

<ul>
<li>退出：<code>Ctrl-D</code> or <code>exit</code></li>
<li>detach：<code>Ctrl-p + Ctrl-q</code></li>
<li>attach: <code>docker attach CONTAINER ID</code></li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openebula镜像制作]]></title>
    <link href="http://kumu-Linux.github.io/blog/2014/04/25/openebula-image/"/>
    <updated>2014-04-25T20:45:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2014/04/25/openebula-image</id>
    <content type="html"><![CDATA[<p><code>qemu-img</code>和<code>qemu-kvm</code>命令是制作系统镜像的重要工具，在介绍这两个工具之前，稍微简单说明下虚拟机镜像格式，目前虚拟机有多种镜像格式可供选择，常见的有如<code>raw</code>、<code>vdi</code>、<code>qcow2</code>、<code>vmdk</code>、<code>qed</code>、<code>vhd</code>等格式。</p>

<!--more-->


<h2>qemu-img</h2>

<p><code>qemu-img</code>是QEMU的磁盘管理工具，支持多种虚拟镜像格式</p>

<p><code>bash
$ qemu-img -h | grep Supported
Supported formats: raw cow qcow vdi vmdk cloop dmg bochs vpc vvfat
qcow2 qed parallels nbd blkdebug host_cdrom host_floppy host_device file
</code></p>

<p><code>qemu-img</code>默认创建的格式是<code>raw</code>，man手册中对几种格式也都有介绍。以下为对raw和qcow2镜像的详细介绍：</p>

<h3>raw</h3>

<p>原始的磁盘镜像格式，qemu-img默认支持的格式，它的优势在于它非常简单而且非常容易移植到其他模拟器（emulator，QEMU 也是一个emulator）上去使用。如果客户机文件系统（如Linux上的ext2/ext3/ext4、Windows的NTFS）支持“空洞” （hole），那么镜像文件只有在被写有数据的扇区才会真正占用磁盘空间，从而有节省磁盘空间的作用。<code>qemu-img</code>默认的<code>raw</code>格式的文件其实是稀疏文件（sparse file）[<em>稀疏文件就是在文件中留有很多空余空间，留备将来插入数据使用。如果这些空余空间被ASCII码的NULL字符占据，并且这些空间相当大，那么，这个文件就被称为稀疏文件，而且，并不分配相应的磁盘块。</em>]，dd命令创建的也是raw格式，不过dd一开始就让镜像实际占用了分配的空间，而没有使用稀疏文件的方式对待空洞而节省磁盘空间。尽管一开始就实际占用磁盘空间的方式没有节省磁盘的效果，不过它在写入新的数据时不需要宿主机从现有磁盘空间中分配，从而在第一次写入数据时性能会比稀疏文件的方式更好一点。简单来说，raw有以下几个特点：</p>

<ul>
<li>寻址简单，访问效率高</li>
<li>可以通过格式转换工具方便地转换为其它格式</li>
<li>格式实现简单，不支持压缩、快照和加密</li>
<li>能够直接被宿主机挂载，不用开虚拟机即可在宿主和虚拟机间进行数据传输</li>
</ul>


<h3>qcow2</h3>

<p><code>qcow2</code>是qcow的一种改进，是Qemu实现的一种虚拟机镜像格式。更小的虚拟硬盘空间（尤其是宿主分区不支持hole的情况下），支持压缩、加密、快照功能，磁盘读写性能较raw差。</p>

<h3>qemu-img它支持的命令分为如下几种</h3>

<ul>
<li>（1）check [-f fmt] filename</li>
</ul>


<p>对磁盘镜像文件进行一致性检查，查找镜像文件中的错误，目前仅支持对<code>“qcow2”</code>、<code>“qed”</code>、<code>“vdi”</code>格式文件的检查。其中，<code>qcow2</code>是 QEMU 0.8.3版本引入的镜像文件格式，也是目前使用最广泛的格式。<code>qed</code>（QEMU enhanced disk）是从QEMU 0.14版开始加入的增强磁盘文件格式，为了避免qcow2格式的一些缺点，也为了提高性能，不过目前还不够成熟。而<code>vdi</code>（Virtual Disk Image）是Oracle的VirtualBox虚拟机中的存储格式。参数-f fmt是指定文件的格式，如果不指定格式<code>qemu-img</code>会自动检测，<code>filename</code>是磁盘镜像文件的名称（包括路径）。</p>

<p><code>bash
$ qemu-img check CentOS6.4-x86_64.qcow2
No errors were found on the image.
</code></p>

<ul>
<li>（2）create [-f fmt] filename [size]</li>
</ul>


<p>创建一个格式为fmt大小为size文件名为filename的镜像文件。</p>

<p><code>bash
$ qemu-img create -f qcow2 test.qcow2 10G
Formatting 'test.qcow2', fmt=qcow2 size=10737418240 encryption=off cluster_size=65536
$ qemu-img create -f qcow2 test.raw 10G
Formatting 'test.raw', fmt=qcow2 size=10737418240 encryption=off cluster_size=65536
</code></p>

<blockquote><p><strong>注意</strong>：这里的qcow2后缀只是为了便于自己区分格式方便，如果不加后缀也可以通过qemu-img来获取镜像的格式。</p></blockquote>

<ul>
<li>（3）info [-f fmt] filename</li>
</ul>


<p>显示filename镜像文件的信息。如果文件是使用稀疏文件的存储方式，也会显示出它的本来分配的大小以及实际已占用的磁盘空间大小。如果文件中存放有客户机快照，快照的信息也会被显示出来。</p>

<p><code>bash
$ qemu-img info test.qcow2
image: test.qcow2
file format: qcow2
virtual size: 10G (10737418240 bytes)
disk size: 136K
cluster_size: 65536
$ qemu-img info test.raw    //qemu-img生成raw格式镜像也是采用稀疏文件方式存储的
image: test.raw
file format: qcow2
virtual size: 10G (10737418240 bytes)
disk size: 136K
cluster_size: 65536
$ dd &lt;/dev/zero &gt;test.dd bs=1MB count=1000
1000+0 records in
1000+0 records out
1000000000 bytes (1.0 GB) copied, 1.80597 s, 554 MB/s
$ qemu-img info test.dd //可以看到dd产生的格式也是raw格式的，并且没有用到稀疏存储方式
image: test.dd
file format: raw
virtual size: 954M (1000000000 bytes)
disk size: 954M
</code></p>

<ul>
<li>（4） convert [-c] [-f fmt] [-O output_fmt] [-o options] filename [filename2 [...]] output_filename</li>
</ul>


<p>镜像格式转换，将fmt格式的filename镜像文件根据options选项转换为格式为<code>output_fmt</code>的名为<code>output_filename</code>的镜像文件。它支持不同格式的镜像文件之间的转换，比如可以用VMware用的vmdk格式文件转换为qcow2文件，这对从其他虚拟化方案转移到KVM上的用户非常有用。一般来说，输入文件格式fmt由qemu-img工具自动检测到，而输出文件格式output_fmt根据自己需要来指定，默认会被转换为与raw文件格式（且默认使用稀疏文件的方式存储以节省存储空间）。
其中，<code>“-c”</code>参数是对输出的镜像文件进行压缩，不过只有qcow2和qcow格式的镜像文件才支持压缩，而且这种压缩是只读的，如果压缩的扇区被重写，则会被重写为未压缩的数据。同样可以使用<code>“-o options”</code>来指定各种选项，如：后端镜像、文件大小、是否加密等等。使用<code>backing_file</code>选项来指定后端镜像，让生成的文件是<code>copy-on-write</code>的增量文件，这时必须让转换命令中指定的后端镜像与输入文件的后端镜像的内容是相同的，尽管它们各自后端镜像的目录、格式可能不同。</p>

<p>如果使用<code>qcow2</code>、<code>qcow</code>、<code>cow</code>等作为输出文件格式来转换<code>raw</code>格式的镜像文件（非稀疏文件格式），镜像转换还可以起到将镜像文件转化为更小的镜像，因为它可以将空的扇区删除使之在生成的输出文件中并不存在。</p>

<p><code>bash
$ qemu-img info test.dd
image: test.dd
file format: raw
virtual size: 954M (1000000000 bytes)
disk size: 954M
$ qemu-img convert -O qcow2  test.dd test_qcow2.qcow2
$ qemu-img info test_qcow2.qcow2
image: test_qcow2.qcow2
file format: qcow2
virtual size: 954M (1000000000 bytes)
disk size: 136K
cluster_size: 65536
</code></p>

<p>以上介绍了<code>qemu-img</code>的基本使用方法之后，关于<code>qemu-img</code>的更多高级用法可以参考man手册</p>

<h3>qemu-kvm</h3>

<h4>新建测试镜像</h4>

<p>因为qcow2的一些特性，这里采用qcow2格式制作系统镜像</p>

<p>``` bash</p>

<h1>qemu-img create -f qcow2 CentOS6.4-x86_64-tpl.qcow2 8G</h1>

<h1>chown oneadmin:oneadmin CentOS6.4-x86_64-tpl.qcow2</h1>

<p>Formatting 'CentOS6.4-x86_64-tpl.qcow2', fmt=qcow2 size=8589934592 encryption=off cluster_size=65536
```</p>

<h4>安装系统</h4>

<p>``` bash</p>

<h1>/usr/libexec/qemu-kvm -m 1024 -cdrom /data/images/CentOS-6.4-x86_64-bin-DVD1.iso -drive \</h1>

<p>file=/data/images/CentOS6.4-x86_64-tpl.qcow2,if=virtio -net nic,model=virtio \
-net tap,script=no  -boot d -nographic -vnc :0
```</p>

<p>上面命令参数解释如下：</p>

<pre><code>-m                      指定内存大小
-cdrom                  指定系统iso镜像
-drive file=xx,if=xx    指定硬盘镜像,file=镜像文件名,if=镜像格式类型
-net nic,model=xx       表示网卡配置,model=模拟网卡类型,默认rt18139
-net tap,script=no      虚拟设备，桥接网络,script表启动虚拟机自动执行网络配置脚本，如果不需要启动，写no即可
-boot d                 系统启动顺序,d表示表示cdrom
-nographic              关闭图形输出
-vnc :0                 开启vnc监听
</code></pre>

<p>详细的关于<code>qemu-kvm</code>的参数使用说明请参考man手册。</p>

<p>输入以上命令之后，通过VNC客户端连接按照正常的安装流程安装系统即可。默认VNC端口从5900开始。</p>

<h2>桥接网络</h2>

<p>如果虚拟机需要和外界通信，则需要创建桥接网络，之前介绍<code>qemu-kvm</code>安装时提到<code>-net tap,script=no</code>选项，默认只是创建桥接虚拟网络，并没有启用，只有启用了才可以设置对应网络配置和外界通信。</p>

<h3>手动桥接</h3>

<p>``` bash</p>

<h1>ip link show dev tap0         //使用如上方式默认创建虚拟网卡tap0，状态为DOWN</h1>

<p>37: tap0: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 500</p>

<pre><code>link/ether d2:b0:af:7b:23:0f brd ff:ff:ff:ff:ff:ff
</code></pre>

<h1>brctl show br0                //查看桥接列表，没有tap0</h1>

<p>bridge name   bridge id       STP enabled interfaces
br0       8000.b8975a626020   no      eth0
```</p>

<p>通过以下方式桥接网络</p>

<p>``` bash</p>

<h1>ip link set tap0 up           //使tap0状态变为up</h1>

<h1>brctl addif br0 tap0          //桥接tap0到br0</h1>

<h1>brctl show br0                //显示tap0已经加入到桥接列表</h1>

<p>bridge name   bridge id       STP enabled interfaces
br0       8000.b8975a626020   no      eth0</p>

<pre><code>                                 tap0
</code></pre>

<p>```</p>

<p>如此，配置好虚拟机的网络就可以和外界通信了。</p>

<p><code>brctl delif br0 tap0</code>删除桥接网络，<code>qemu-kvm</code>工具在客户机关闭时会自动解除TAP设备的bridge绑定，所以这一步无需操作。</p>

<h3>脚本实现</h3>

<p>如果不想每次都手动操作，则可以通过脚本自动化实现虚拟网卡的桥接。使用选项<code>-net tap,script=/tmp/qemu-ifup.sh</code> 把之前的no替换为需要执行的脚本，以下为<code>qemu-ifup.sh</code>脚本内容</p>

<p>``` bash</p>

<h1>cat /tmp/qemu-ifup.sh</h1>

<h1>!/bin/bash</h1>

<h1>桥接网络设备</h1>

<p>switch=br0                  //设置桥接网卡</p>

<p>if [ -n $1 ]; then          //$1为qemu-kvm传递值，这里是tap</p>

<pre><code>ip link set $1 up
brctl addif ${switch} $1
exit 0
</code></pre>

<p>else
   echo "no interface!"
   exit 1
fi
```</p>

<h2>系统相关优化</h2>

<p>完成系统安装配置之后，需要对镜像模板系统做如下一系列优化操作：</p>

<h3>selinux、iptables、服务、文件描述符设置</h3>

<p># 关闭SELINUX</p>

<pre><code>sed -i -c 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/sysconfig/selinux
</code></pre>

<p># iptables根据相关需求配置，一般关闭iptables服务</p>

<p># 关闭系统其它额外的服务</p>

<p><code>`` bash
service=</code>chkconfig --list | grep '3:on' | awk '{print $1}'`
for i in $service
do</p>

<pre><code>case $i in
    acpid | crond | irqbalance |  messagebus | network | sshd | rsyslog | udev-post)
        chkconfig --level 2345 $i on
    ;;
    *)
        chkconfig --level 2345 $i off   
    ;;
esac    
</code></pre>

<p>done
```</p>

<p># 文件描述符相关配置</p>

<p><code>bash
cat &gt;&gt;/etc/security/limits.conf &lt;&lt;EOF
*               soft    nofile          65535
*               hard    nofile          65535
EOF
sed -i '/1024/s/1024/65535/' /etc/security/limits.d/90-nproc.conf
</code></p>

<blockquote><p><strong>注：</strong> 经测试acpid服务必须安装且在虚拟机系统中开启，否则OpenNebula web端和shell终端发送关机命令无效。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[grub install with kvm virtio disk]]></title>
    <link href="http://kumu-Linux.github.io/blog/2014/03/26/grub-virtio/"/>
    <updated>2014-03-26T14:31:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2014/03/26/grub-virtio</id>
    <content type="html"><![CDATA[<p>grub-install ERROR: not suitable driver was found</p>

<!--more-->


<ul>
<li><p>First
<code>bash
grub-install /dev/vda
</code></p></li>
<li><p>Second
``` bash</p>

<h1>grub</h1>

<blockquote><p>device (hd0) /dev/vda
root (hd0,0)
setup (hd0)
quit
```</p></blockquote></li>
<li><p><code>/boot/grub/device.map</code>
<code>bash
(hd0) /dev/vda
</code></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
