<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 运维利器 | Linux SA Notes By 枯木]]></title>
  <link href="http://kumu-Linux.github.com/blog/categories/yun-wei-li-qi/atom.xml" rel="self"/>
  <link href="http://kumu-Linux.github.com/"/>
  <updated>2013-05-21T18:18:42+08:00</updated>
  <id>http://kumu-Linux.github.com/</id>
  <author>
    <name><![CDATA[枯木]]></name>
    <email><![CDATA[1988.wulei@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[dmidecode]]></title>
    <link href="http://kumu-Linux.github.com/blog/2013/04/27/dmidecode/"/>
    <updated>2013-04-27T07:39:00+08:00</updated>
    <id>http://kumu-Linux.github.com/blog/2013/04/27/dmidecode</id>
    <content type="html"><![CDATA[<p>在介绍dmidecode命令之前，先介绍一下DMI。所谓DMI，即DesktopManagement Interface。也有被称为SMBIOS，即System Management BIOS。DMI表的意义在于让我们在不探测硬件实体的情况下获取硬件的部分信息，方便了用户，但也同时表明，表中的信息可能是不可靠的。</p>

<!--more-->


<p><code>dmidecode</code>的作用则是将DMI表中的信息用人可以读懂的方式显示出来。</p>

<p>最简单的使用方法，它将显示dmidecode所能获取到的全部dmi信息：
``` bash</p>

<h1>dmidecode</h1>

<p>```</p>

<p>但是显示所有的信息不便于我们获取想要获取的信息，那么就需要结合其它选项获取信息</p>

<p><strong>常用参数:</strong></p>

<ul>
<li>-q 或 --quiet

<ul>
<li>不显示太多信息，比如某条数据是从哪里读来的等等，为了得到简洁的信息，此条很有用</li>
</ul>
</li>
<li>-t 或 --type TYPE

<ul>
<li>指定要显示类型的信息</li>
</ul>
</li>
<li>-s 或 --string KEYWORD

<ul>
<li>显示特定的关键字</li>
</ul>
</li>
</ul>


<p><strong>-t或--type后的文本参数</strong></p>

<pre><code>bios        bios的各项信息
system      系统信息，在我的笔记本上可以看到版本、型号、序号等信息。
baseboard   主板信息
chassis     底板信息
processor   CPU的详细信息
memory      内存信息，包括目前插的内存条数及大小，支持的单条最大内存和总内存大小等
cache       缓存信息
connector   PCI设备信息
slot        插槽信息 
</code></pre>

<p>``` bash</p>

<h1>dmidecode -t</h1>

<p>dmidecode: option requires an argument -- 't'
Type number or keyword expected
Valid type keywords are:
  bios
  system
  baseboard
  chassis
  processor
  memory
  cache
  connector
  slot
```</p>

<p><strong>dmidecode -s</strong>:
``` bash</p>

<h1>dmidecode -s</h1>

<p>dmidecode: option requires an argument -- 's'
String keyword expected
Valid string keywords are:
  bios-vendor
  bios-version
  bios-release-date
  system-manufacturer
  system-product-name
  system-version
  system-serial-number
  system-uuid
  baseboard-manufacturer
  baseboard-product-name
  baseboard-version
  baseboard-serial-number
  baseboard-asset-tag
  chassis-manufacturer
  chassis-type
  chassis-version
  chassis-serial-number
  chassis-asset-tag
  processor-family
  processor-manufacturer
  processor-version
  processor-frequency
```</p>

<p><strong>常用命令举例</strong></p>

<ul>
<li>1、查看服务器型号：dmidecode | grep 'Product Name'</li>
<li>2、查看系统序列号：dmidecode -s system-serial-number</li>
<li>3、查看内存信息：dmidecode -t memory</li>
<li>4、查看OEM信息：dmidecode -t 11</li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lsof在Linux中的10个例子<译>]]></title>
    <link href="http://kumu-Linux.github.com/blog/2013/04/08/lsof/"/>
    <updated>2013-04-08T10:19:00+08:00</updated>
    <id>http://kumu-Linux.github.com/blog/2013/04/08/lsof</id>
    <content type="html"><![CDATA[<p>本文主要是介绍lsof相关使用方法，原文主要是10个例子的讲解，笔者又新增了一些实用案例，<a href="http://www.tecmint.com/10-lsof-command-examples-in-linux/">原文地址</a> 。</p>

<p>lsof的意思是'列出打开的文件'，用于找出哪些文件被哪些进程打开或是占用。我们都知道Linux/UNIX的理念就是一切皆文件(包括pipes管道、sockets、directories目录、devices设备等等)。使用lsof命令的原因之一就是，当一个磁盘不能被卸载时，借助lsof这个命令我们可以轻易的识别哪些文件正在被占用。</p>

<!--more-->


<h2>1、通过lsof命令列出所有打开的文件</h2>

<p>在下面的例子中，它会以长列表的形式显示打开的文件，为了便于理解，它以Command、PID、USER、FD、TYPE分类
{% codeblock lang:cpp %}</p>

<h1>lsof</h1>

<p>COMMAND     PID   USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME
init          1   root  cwd       DIR                8,3     4096          2 /
init          1   root  rtd       DIR                8,3     4096          2 /
init          1   root  txt       REG                8,3   150352     527181 /sbin/init
init          1   root  mem       REG                8,3    65928     654110 /lib64/libnss_files-2.12.so
init          1   root    0u      CHR                1,3      0t0       4021 /dev/null
{% endcodeblock %}</p>

<p>若不指定条件默认将显示所有进程打开的所有文件,lsof输出各列信息的意义如下：</p>

<ul>
<li>COMMAND：进程的名称</li>
<li>PID：进程标识符</li>
<li>USER：进程所有者</li>
<li>FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等

<ul>
<li>cwd 表示应用程序的当前工作目录</li>
<li>RTD 根目录</li>
<li>txt txt类型文件是程序代码，应用程序二进制文件本身或共享库</li>
<li>MEM 内存映射文件</li>
<li>u 表示该文件被打开并处于读取/写入模式，而不是只读 ® 或只写 (w) 模式。</li>
<li>W 表示该应用程序具有对整个文件的写锁。该文件描述符用于确保每次只能打开一个应用程序实例。</li>
<li>R 读访问</li>
<li>初始打开每个应用程序时，都具有三个文件描述符，从 0 到 2，分别表示标准输入、输出和错误流。所以大多数应用程序所打开的文件的FD都是从3开始。</li>
</ul>
</li>
<li>TYPE：文件类型，如DIR、REG等

<ul>
<li>DIR 目录</li>
<li>REG 基本文件</li>
<li>CHR 字符特殊文件</li>
<li>FIFO 先进先出</li>
<li>UNIX unix域套接字</li>
</ul>
</li>
<li>DEVICE：指定磁盘的名称</li>
<li>SIZE：文件的大小</li>
<li>NODE：索引节点（文件在磁盘上的标识）</li>
<li>NAME：打开文件的确切名称</li>
</ul>


<h2>2、列出特定用户打开的文件</h2>

<p>使用-u选项后接用户指定某个用户打开文件
{% codeblock lang:cpp %}</p>

<h1>lsof -u apache</h1>

<p>COMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
httpd   6032 apache  cwd    DIR    8,3     4096       2 /
httpd   6032 apache  rtd    DIR    8,3     4096       2 /
httpd   6032 apache  txt    REG    8,3   354688 1605148 /usr/sbin/httpd
httpd   6032 apache  mem    REG    8,3    65928  654110 /lib64/libnss_files-2.12.so
{% endcodeblock %}</p>

<h2>3、查找特定端口运行的进程</h2>

<p>使用-i选项来查找正在运行特定端口的进程
{% codeblock lang:cpp %}</p>

<h1>lsof -i TCP:53</h1>

<p>COMMAND   PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
named   16885 named   20u  IPv4  61664      0t0  TCP localhost:domain (LISTEN)</p>

<h1>lsof -i UDP:53</h1>

<p>COMMAND   PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
named   16885 named  512u  IPv4  61663      0t0  UDP localhost:domain</p>

<h1>lsof -i:53</h1>

<p>named   16885 named   20u  IPv4  61664      0t0  TCP localhost:domain (LISTEN)
named   16885 named  512u  IPv4  61663      0t0  UDP localhost:domain
{% endcodeblock %}</p>

<h2>4、列出ipv4和ipv6的文件</h2>

<p>{% codeblock lang:cpp %}</p>

<h1>lsof -i 4</h1>

<p>COMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd      1239  root    3u  IPv4  10081      0t0  TCP *:ssh (LISTEN)</p>

<h1>lsof -i 6</h1>

<p>COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd     1239   root    4u  IPv6  10083      0t0  TCP *:ssh (LISTEN)
{% endcodeblock %}</p>

<h2>5、列出TCP端口范围1-1024端口</h2>

<p>列出打开1-1024端口所有正在运行的程序
{% codeblock lang:cpp %}</p>

<h1>lsof -i TCP:1-1024</h1>

<p>COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd     1239   root    3u  IPv4  10081      0t0  TCP <em>:ssh (LISTEN)
sshd     1239   root    4u  IPv6  10083      0t0  TCP </em>:ssh (LISTEN)
httpd    2142   root    4u  IPv6  13337      0t0  TCP *:http (LISTEN)
{% endcodeblock %}</p>

<h2>6、通过脱字符排除某个用户</h2>

<p>{% codeblock lang:cpp %}</p>

<h1>lsof -u<sup>root</sup></h1>

<p>COMMAND     PID   USER   FD   TYPE             DEVICE SIZE/OFF    NODE NAME
dbus-daem  1212   dbus  cwd    DIR                8,3     4096       2 /
dbus-daem  1212   dbus  rtd    DIR                8,3     4096       2 /
{% endcodeblock %}</p>

<h2>7、查找特定用户使用文件和命令</h2>

<p>{% codeblock lang:cpp %}</p>

<h1>lsof -i -u apache</h1>

<p>COMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
httpd     6032 apache  txt    REG    8,3   354688 1605148 /usr/sbin/httpd
httpd     6032 apache  mem    REG    8,3     9488  271645 /usr/lib64/apr-util-1/apr_ldap-1.so
{% endcodeblock %}</p>

<h2>8、列出所有网络连接</h2>

<p>{% codeblock lang:cpp %}</p>

<h1>lsof -i</h1>

<p>COMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd      1239   root    3u  IPv4  10081      0t0  TCP <em>:ssh (LISTEN)
sshd      1239   root    4u  IPv6  10083      0t0  TCP </em>:ssh (LISTEN)
{% endcodeblock %}</p>

<h2>9、采用pid搜索</h2>

<p>{% codeblock lang:cpp %}</p>

<h1>lsof -p 1</h1>

<p>COMMAND PID USER   FD   TYPE             DEVICE SIZE/OFF   NODE NAME
init      1 root  cwd    DIR                8,3     4096      2 /
init      1 root  rtd    DIR                8,3     4096      2 /
init      1 root  txt    REG                8,3   150352 527181 /sbin/init
{% endcodeblock %}</p>

<h2>10、杀死某个特定用户的所有活动</h2>

<p>{% codeblock lang:cpp %}</p>

<h1>kill -9 <code>lsof -t -u named</code></h1>

<p>{% endcodeblock %}</p>

<h3>补充:</h3>

<p>查看谁在使用文件系统,在卸载文件系统时，如果某个文件系统中有任何打开文件，操作一般会失败
{% codeblock lang:cpp %}</p>

<h1>lsof /mnt/</h1>

<p>COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
bash    16672 root  cwd    DIR   11,0     8192 1856 /mnt
lsof    17041 root  cwd    DIR   11,0     8192 1856 /mnt
lsof    17042 root  cwd    DIR   11,0     8192 1856 /mnt
{% endcodeblock %}</p>

<p>查看被删除的文件
{% codeblock lang:cpp %}</p>

<h1>lsof | grep deleted --color</h1>

<p>console-k  1291   root  txt       REG                8,3   155008    1577669 /usr/sbin/console-kit-daemon.#prelink#.bXthE2 (deleted)
tail      17553   root    3r      REG                8,3        6     523317 /tmp/test2 (deleted)
{% endcodeblock %}</p>

<h2>应用实例</h2>

<p>以下两个实例分别引用其它博主的实例，笔者也在实际过程中遇到过，作用很大，所以引用过来</p>

<h3>实例1 恢复删除的文件</h3>

<ul>
<li>实例引用<a href="http://www.turbolinux.com.cn/turbo/wiki/doku.php?id=%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF:lsof">turbolinux</a></li>
</ul>


<p>当Linux计算机受到入侵时，常见的情况是日志文件被删除，以掩盖攻击者的踪迹。管理错误也可能导致意外删除重要的文件，比如在清理旧日志时，意外地删除了数据库的活动事务日志。有时可以通过lsof来恢复这些文件。</p>

<p>当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。</p>

<p>在/proc 目录下，其中包含了反映内核和进程树的各种文件。/proc目录挂载的是在内存中所映射的一块区域，所以这些文件和目录并不存在于磁盘中，因此当我们对这些文件进行读取和写入时，实际上是在从内存中获取相关信息。大多数与 lsof 相关的信息都存储于以进程的 PID 命名的目录中，即/proc/1234 中包含的是PID为1234 的进程的信息。每个进程目录中存在着各种文件，它们可以使得应用程序简单地了解进程的内存空间、文件描述符列表、指向磁盘上的文件的符号链接和其他系统信息。lsof 程序使用该信息和其他关于内核内部状态的信息来产生其输出。所以lsof 可以显示进程的文件描述符和相关的文件名等信息。也就是我们通过访问进程的文件描述符可以找到该文件的相关信息。</p>

<p>当系统中的某个文件被意外地删除了，只要这个时候系统中还有进程正在访问该文件，那么我们就可以通过lsof从/proc目录下恢复该文件的内容。 假如由于误操作将/var/log/messages文件删除掉了，那么这时要将/var/log/messages文件恢复的方法如下：</p>

<p>首先使用lsof来查看当前是否有进程打开/var/logmessages文件，如下:
{% codeblock lang:cpp %}</p>

<h1>lsof |grep /var/log/messages</h1>

<p>syslogd   1283      root    2w      REG        3,3  5381017    1773647 /var/log/messages (deleted)
{% endcodeblock %}</p>

<p>从上面的信息可以看到 PID 1283（syslogd）打开文件的文件描述符为 2。同时还可以看到/var/log/messages已经标记被删除了。因此我们可以在 /proc/1283/fd/2 （fd下的每个以数字命名的文件表示进程对应的文件描述符）中查看相应的信息，如下：
{% codeblock lang:cpp %}</p>

<h1>head -n 10 /proc/1283/fd/2</h1>

<p>Aug  4 13:50:15 holmes86 syslogd 1.4.1: restart.
Aug  4 13:50:15 holmes86 kernel: klogd 1.4.1, log source = /proc/kmsg started.
Aug  4 13:50:15 holmes86 kernel: Linux version 2.6.22.1-8 (root@everestbuilder.linux-ren.org) (gcc version 4.2.0) #1 SMP Wed Jul 18 11:18:32 EDT 2007
Aug  4 13:50:15 holmes86 kernel: BIOS-provided physical RAM map:
Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 0000000000000000 - 000000000009f000 (usable)
Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 000000000009f000 - 00000000000a0000 (reserved)
Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 0000000000100000 - 000000001f7d3800 (usable)
Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 000000001f7d3800 - 0000000020000000 (reserved)
Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 00000000e0000000 - 00000000f0007000 (reserved)
Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 00000000f0008000 - 00000000f000c000 (reserved)
{% endcodeblock %}</p>

<p>从上面的信息可以看出，查看 /proc/1283/fd/2 就可以得到所要恢复的数据。如果可以通过文件描述符查看相应的数据，那么就可以使用 I/O 重定向将其复制到文件中，如:
{% codeblock lang:cpp %}
cat /proc/1283/fd/2 > /var/log/messages
{% endcodeblock %}
对于许多应用程序，尤其是日志文件和数据库，这种恢复删除文件的方法非常有用。</p>

<h3>应用实例2 磁盘剩余空间和du显示相差太大</h3>

<ul>
<li>实例引用：<a href="http://chenxu.yo2.cn/articles/lsof.html">orz DBA</a></li>
</ul>


<p>今天一同事说文件系统/tmp目录下空间用满了，当时du统计目录所有文件的时候却很小。听到这个现象，第一感觉就是应该有大文件被删除，但是这个文件可能依然被其他程序打开，导致这个文件不能被清除。登上服务器使用lsof看了一下，果然如此，具体排查过程如下：
{% codeblock lang:python %}
$ df -h
Filesystem Size Used Avail Use% Mounted on
/dev/sda5 8.7G 7.9G 407M 96% /tmp
$ sudo lsof | grep /tmp | sort -k7 -nr  #注：其实直接lsof | grep deleted 即可
sleep 18833 peien.htg 1w REG 8,5 8321143673 54 /tmp/netstat.log (deleted)
netstat_2 13571 peien.htg 1w REG 8,5 8321143673 54 /tmp/netstat.log (deleted)
{% endcodeblock %}</p>

<p>上面lsof输出结果的第二列是PID,倒数第三列是占用空间大小</p>

<p>可以看到文件/tmp/netstat.log (deleted)占用7个多G的空间，虽然被删除了，但是还是有进程打开它。</p>

<p>然后，用PID看看是哪个程序占用这个文件：
{% codeblock lang:python %}
$ ps -ef | grep 13571
51717 13571 1 0 2011 ? 00:15:00 /bin/bash /tmp/netstat_20110829.sh
51717 21456 13571 0 09:40 ? 00:00:00 sleep 10
zhuxu 21458 17014 0 09:40 pts/0 00:00:00 grep 13571
{% endcodeblock %}</p>

<p>将这个进程KILL掉后，就OK了：
{% codeblock lang:python %}
$ sudo kill -9 13571
$ df -h
Filesystem Size Used Avail Use% Mounted on
/dev/sda5  8.7G 56M  8.2G 1%  /tmp
{% endcodeblock %}</p>

<p>--EOF--</p>
]]></content>
  </entry>
  
</feed>
