<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 运维利器 | Linux SA Notes By 枯木]]></title>
  <link href="http://kumu-Linux.github.io/blog/categories/yun-wei-li-qi/atom.xml" rel="self"/>
  <link href="http://kumu-Linux.github.io/"/>
  <updated>2013-09-22T11:33:14+08:00</updated>
  <id>http://kumu-Linux.github.io/</id>
  <author>
    <name><![CDATA[枯木]]></name>
    <email><![CDATA[1988.wulei@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux下终端利器tmux]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/08/06/tmux/"/>
    <updated>2013-08-06T11:05:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/08/06/tmux</id>
    <content type="html"><![CDATA[<blockquote><p>"君子生非异也，善假于物也" 。--语出《荀子·劝学》</p></blockquote>

<p>如果记得没错的话，《荀子·劝学》我们这一代高中的时候应该都读过这篇文章。原意大概是君子的资质与一般人没有什么区别，君子之所以高于一般人，是因为他能善于利用外物。对于技术人来说，好工具的选择和使用往往可以省去很多不必要的麻烦，好的开源工具很多，看你如何去使用。对于终端复用工具这里推荐使用tmux，当然此类工具比较好的还有screen，不过相对<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-screen/">screen</a> 这里我更倾向于推荐tmux[强悍的分屏等]。</p>

<!--more-->


<p>如果仅仅只是多标签的功能，那么putty结合一些工具也可以做到，或者干脆使用xshell，当然tmux此类工具不仅仅是那么简单。另外一个选择使用tmux/screen工具的原因是，有时我们会经常需要SSH或者telent远程登录到Linux服务器，有一些任务需要长时间运行，比如系统备份、数据传输等。通常情况下我们都是开一个远程终端窗口，因为执行时间比较长，一般需要等待它执行完毕，在此过程中不能关闭窗口或者网络原因断开连接，断开之后就Game Over了。这个功能就有点类似<code>nohup</code>和<code>setsid</code>命令的实现了，而tmux/screen则集nohup/setsid和多标签于一身。废话少说，我们接下来看如何安装使用它。</p>

<h3>安装</h3>

<p>安装的话这里就不过说明了，不同的Linux发行版相应的包管理机制不同，安装tmux包即可。</p>

<h3>使用技巧</h3>

<h4>几个名词</h4>

<p>tmux主要包括以下几个模块：</p>

<table>
    <tr>
        <td>session</td>
        <td>会话:一个服务器可以包含多个会话</td>
    </tr>
    <tr>
        <td>window</td>
        <td>窗口:一个会话可以包含多个窗口</td>
    </tr>
    <tr>
        <td>pane</td>
        <td>面板:一个窗口可以包含多个面板[强悍的分屏]</td>
    </tr>
</table>




<p></p>


<h4>小试牛刀</h4>

<p>列出了tmux的几个基本模块之后，就要来点实实在在的干货了，和<code>screen</code>默认激活控制台的<code>Ctrl+a</code>不同，tmux默认的是<code>Ctrl+b</code>，使用快捷键之后就可以执行一些相应的指令了。当然如果你不习惯使用<code>Ctrl+b</code>，也可以在<code>~/.tmux</code>文件中加入以下内容把快捷键变为<code>Ctrl+a</code>：</p>

<p>``` bash</p>

<h1>Set prefix key to Ctrl-a</h1>

<p>unbind-key C-b
set-option -g prefix C-a
```</p>

<p>以下所有的操作都是激活控制台之后，即键入<code>Ctrl+b</code>前提下才可以使用的命令【这里假设快捷键没改，改了的话则用<code>Ctrl+b</code>】。</p>

<p><u>基本操作</u>：</p>

<table>
    <tr>
        <td>?</td>
        <td>列出所有快捷键；按q返回</td>
    </tr>
    <tr>
        <td>d</td>
        <td>脱离当前会话,可暂时返回Shell界面，输入tmux attach能够重新进入之前会话</td>
    </tr>
    <tr>
        <td>s</td>
        <td>选择并切换会话；在同时开启了多个会话时使用</td>
    </tr>
    <tr>
        <td>D</td>
        <td>选择要脱离的会话；在同时开启了多个会话时使用</td>
    </tr>   
    <tr>
        <td>:</td>
        <td>进入命令行模式；此时可输入支持的命令，例如kill-server所有tmux会话</td>
    </tr>
    <tr>
        <td>[</td>
        <td>复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出</td>
    </tr>
    <tr>
        <td>]</td>
        <td>进入粘贴模式，粘贴之前复制的内容，按q/Esc退出</td>
    </tr>
    <tr>
        <td>~</td>
        <td>列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</td>
    </tr>
    <tr>
        <td>t</td>
        <td>显示当前的时间</td>
    </tr>
    <tr>
        <td>Ctrl+z</td>
        <td>挂起当前会话</td>
    </tr>
</table>




<p></p>


<p><u>窗口操作</u>:</p>

<table>
    <tr>
        <td>c</td>
        <td>创建新窗口</td>
    </tr>
    <tr>
        <td>&</td>
        <td>关闭当前窗口</td>
    </tr>
    <tr>
        <td>数字键</td>
        <td>切换到指定窗口</td>
    </tr>
    <tr>
        <td>p</td>
        <td>切换至上一窗口</td>
    </tr>
    <tr>
        <td>n</td>
        <td>切换至下一窗口</td>
    </tr>
    <tr>
        <td>l</td>
        <td>前后窗口间互相切换</td>
    </tr>
    <tr>
        <td>w</td>
        <td>通过窗口列表切换窗口</td>
    </tr>
    <tr>
        <td>,</td>
        <td>重命名当前窗口，便于识别</td>
    </tr>
    <tr>
        <td>.</td>
        <td>修改当前窗口编号，相当于重新排序</td>
    </tr>
    <tr>
        <td>f</td>
        <td>在所有窗口中查找关键词，便于窗口多了切换</td>
    </tr>
</table>




<p></p>


<p><u>面板操作</u>:</p>

<table>
    <tr>
        <td>"</td>
        <td>将当前面板上下分屏</td>
    </tr>
    <tr>
        <td>%</td>
        <td>将当前面板左右分屏</td>
    </tr>
    <tr>
        <td>x</td>
        <td>关闭当前分屏</td>
    </tr>
    <tr>
        <td>!</td>
        <td>将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</td>
    </tr>
    <tr>
        <td>Ctrl+方向键</td>
        <td>以1个单元格为单位移动边缘以调整当前面板大小</td>
    </tr>
    <tr>
        <td>Alt+方向键</td>
        <td>以5个单元格为单位移动边缘以调整当前面板大小</td>
    </tr>
    <tr>
        <td>空格键</td>
        <td>可以在默认面板布局中切换，试试就知道了</td>
    </tr>
    <tr>
        <td>q</td>
        <td>显示面板编号</td>
    </tr>
    <tr>
        <td>o</td>
        <td>选择当前窗口中下一个面板</td>
    </tr>
    <tr>
        <td>方向键</td>
        <td>移动光标选择对应面板</td>
    </tr>
    <tr>
        <td>{</td>
        <td>向前置换当前面板</td>
    </tr>
    <tr>
        <td>}</td>
        <td>向后置换当前面板</td>
    </tr>
    <tr>
        <td>Alt+o</td>
        <td>逆时针旋转当前窗口的面板</td>
    </tr>
    <tr>
        <td>Ctrl+o</td>
        <td>顺时针旋转当前窗口的面板</td>
    </tr>
    <tr>
        <td>z</td>
        <td>tmux 1.8新特性，最大化当前所在面板</td>
    </tr>
</table>




<p></p>


<h4>.tmux.conf基本配置</h4>

<p>软件到手了，自己怎么舒服就怎么用。定制主要还是在于<code>.tmux.conf</code>配置文件的配置，以下列出我的配置文件：
``` bash</p>

<h1>Set prefix key to Ctrl-a</h1>

<p>unbind-key C-b
set-option -g prefix C-a
bind-key C-a last-window # 方便切换，个人习惯
bind-key a send-prefix</p>

<h1>shell下的Ctrl+a切换到行首在此配置下失效，此处设置之后Ctrl+a再按a即可切换至shell行首</h1>

<h1>reload settings   # 重新读取加载配置文件</h1>

<p>bind R source-file ~/.tmux.conf \; display-message "Config reloaded..."</p>

<h1>Ctrl-Left/Right cycles thru windows (no prefix)</h1>

<h1>不使用prefix键，使用Ctrl和左右方向键方便切换窗口</h1>

<p>bind-key -n "C-Left" select-window -t :-
bind-key -n "C-Right" select-window -t :+</p>

<h1>displays</h1>

<p>bind-key * list-clients</p>

<p>set -g default-terminal "screen-256color"   # use 256 colors
set -g display-time 5000                    # status line messages display
set -g status-utf8 on                       # enable utf-8
set -g history-limit 100000                 # scrollback buffer n lines
setw -g mode-keys vi                        # use vi mode</p>

<h1>start window indexing at one instead of zero 使窗口从1开始，默认从0开始</h1>

<p>set -g base-index 1</p>

<h1>key bindings for horizontal and vertical panes</h1>

<p>unbind %
bind | split-window -h      # 使用|竖屏，方便分屏
unbind '"'
bind - split-window -v      # 使用-横屏，方便分屏</p>

<h1>window title string (uses statusbar variables)</h1>

<p>set -g set-titles-string '#T'</p>

<h1>status bar with load and time</h1>

<p>set -g status-bg blue
set -g status-fg '#bbbbbb'
set -g status-left-fg green
set -g status-left-bg blue
set -g status-right-fg green
set -g status-right-bg blue
set -g status-left-length 90
set -g status-right-length 90
set -g status-left '[#(whoami)]'
set -g status-right '[#(date +" %m-%d %H:%M ")]'
set -g status-justify "centre"
set -g window-status-format '#I #W'
set -g window-status-current-format ' #I #W '
setw -g window-status-current-bg blue
setw -g window-status-current-fg green</p>

<h1>pane border colors</h1>

<p>set -g pane-active-border-fg '#55ff55'
set -g pane-border-fg '#555555'
```</p>

<h4>开启批量执行</h4>

<p>如果已经修改prefix键位<code>Ctrl+a</code>，则<code>Ctrl+a</code>[默认Ctrl+b]后输入<code>:set synchronize-panes</code> ，输入:set sync [TAB]键可自动补齐</p>

<p><img src="http://kumu-Linux.github.io/images/tmux.jpg"></p>

<p></p>


<p>取消批量执行模式重复之前操作即可</p>

<h4>脚本化启动</h4>

<p>把以下脚本内容加入到~/.bashrc，即可每次登录进入到tmux
``` bash
tmux_init()
{</p>

<pre><code>tmux new-session -s "kumu" -d -n "local"    # 开启一个会话
tmux new-window -n "other"          # 开启一个窗口
tmux split-window -h                # 开启一个竖屏
tmux split-window -v "top"          # 开启一个横屏,并执行top命令
tmux -2 attach-session -d           # tmux -2强制启用256color，连接已开启的tmux
</code></pre>

<p>}</p>

<h1>判断是否已有开启的tmux会话，没有则开启</h1>

<p>if which tmux 2>&amp;1 >/dev/null; then</p>

<pre><code>test -z "$TMUX" &amp;&amp; (tmux attach || tmux_init)
</code></pre>

<p>fi
```</p>

<p>效果如下：</p>

<p><img src="http://kumu-Linux.github.io/images/tmux1.jpg"></p>

<p></p>


<p>--EOF--</p>

<h3>参考文档</h3>

<ul>
<li><a href="https://wiki.freebsdchina.org/software/t/tmux">使用tmux</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Tmux">archlinux tmux</a></li>
<li><a href="http://wiki.wutianqi.com/software/tmux.html">Tankywoo tmux wiki</a></li>
<li><a href="http://www.lovelin.info/blog/2012/10/25/tmuxshi-yong-xin-de-xiao-ji/">Tmux 使用心得小记 </a></li>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1">Tmux Openbsd Manual Pages</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[top实践小技巧]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/06/07/top-hacks/"/>
    <updated>2013-06-07T17:32:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/06/07/top-hacks</id>
    <content type="html"><![CDATA[<p>之前介绍了<a href="http://kumu-linux.github.io/blog/2013/06/02/top/">top基本介绍</a>,本章主要介绍一些top的实用技巧。</p>

<!--more-->


<p>终端执行top命令之后【也可后接一些选项，比如<code>top -p 1</code>只监控init进程，<code>top -u root</code>只显示root运行进程等等】，可以敲击如下按键，实现不同功能：</p>

<ul>
<li><code>1</code>(数字1)：列出所有的单个CPU负载情况</li>
<li><code>z</code>:top显示颜色</li>
<li><code>P</code>[大写]:按CPU占用高低顺序列出程序</li>
<li><code>M</code>[大写]:按内存占用高低顺序列出程序</li>
<li><code>x</code>:类似高亮显示，在z显示模式下效果才会更明显</li>
</ul>


<p>如下效果图:</p>

<center><img src="http://kumu-Linux.github.io/images/top1.png" alt="geek" title="geek" width="600" /></center>


<ul>
<li>top显示Swap利用率，使用top命令后按f键，然后按p键，回车之后即可看到Swap状态</li>
</ul>


<center><img src="http://kumu-Linux.github.io/images/top2.png" alt="geek" title="geek" width="600" /></center>


<ul>
<li><code>d</code>:top默认的刷新时间是3s，使用d键可以自定义刷新时间</li>
</ul>


<center><img src="http://kumu-Linux.github.io/images/top3.png" alt="geek" title="geek" width="600" /></center>




<p></p>


<p><strong>top类似上下翻页的方法：</strong></p>

<ul>
<li>shift &lt;  下翻页</li>
<li>shift >   上翻页</li>
</ul>


<p>top默认按cpu占用排序，这也是可以修改的，按F(大写)即可选择相应排序，之后任意键退出即可</p>

<center><img src="http://kumu-Linux.github.io/images/top4.png" alt="geek" title="geek" width="600" /></center>


<ul>
<li><code>c</code>:显示进程命令的全路径与参数</li>
<li><code>f</code>:可以指定top显示的内容，如ppid、swap等都可以选择显示</li>
<li><code>k</code>:输入k之后可以kill掉指定的进程</li>
<li><code>A</code>:分类显示各种系统资源高的进程。可用于快速识别系统上的性能要求极高的任务，<strong>推荐使用</strong></li>
<li><code>h</code>:获取top的命令帮助</li>
<li><code>H</code>:显示线程，默认只显示进程</li>
<li><code>W</code>[大写]:将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法</li>
</ul>


<p>参考: <a href="http://linux.vbird.org/">鸟哥Linux私房菜</a>  <a href="http://www.cyberciti.biz/tips/top-linux-monitoring-tools.html">top - Process Activity Command</a>  <a href="http://how-to.linuxcareer.com/learning-linux-commands-top">Learning Linux Commands: top</a></p>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iproute]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/06/04/iproute/"/>
    <updated>2013-06-04T11:16:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/06/04/iproute</id>
    <content type="html"><![CDATA[<h3>iproute基本介绍</h3>

<p>iproute是用于linux下网络配置工具，该工具包包含以下组件</p>

<!--more-->


<p>``` bash</p>

<h1>rpm -ql  iproute | grep bin</h1>

<p>/sbin/cbq           #流量控制
/sbin/ifcfg         #网络地址配置管理
/sbin/ip            #网络配置命令
/sbin/rtmon         #rtmon listens on netlink socket and monitors routing table changes.
/sbin/tc            #进行流量控制的命令
/usr/sbin/arpd      #收集arp信息保存到本地cache daemon
/usr/sbin/lnstat    #网络统计信息
/usr/sbin/nstat     #显示网络统计信息
/usr/sbin/rtacct    #查看数据包流量状态
【nstat and rtacct are simple tools to monitor kernel snmp counters and network interface statistics.】
/usr/sbin/ss        #类似netstat命令，显示活动连接
```</p>

<p>iproute的中心是<code>ip</code>这个命令，类似<code>arp</code>、<code>ifconfig</code>、<code>route</code>命令虽然这些工具能够工作，但是在Linux2.2和更高版本的内核上就有点out了。</p>

<h3>ip基本使用方法</h3>

<p>``` bash</p>

<h1>ip --help</h1>

<p>Usage: ip [ OPTIONS ] OBJECT { COMMAND | help }</p>

<pre><code>   ip [ -force ] -batch filename
</code></pre>

<p>where  OBJECT := { link | addr | addrlabel | route | rule | neigh | ntable |</p>

<pre><code>               tunnel | maddr | mroute | mrule | monitor | xfrm }
   OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |
                -f[amily] { inet | inet6 | ipx | dnet | link } |
                -o[neline] | -t[imestamp] | -b[atch] [filename] |
                -rc[vbuf] [size]}
</code></pre>

<p>```</p>

<p><strong>OBJECT</strong></p>

<ul>
<li>link          指网络设备，通过此对象命令，我们可以查看及更改网络设备的属性。</li>
<li>addr          地址管理</li>
<li>neigh         arp表管理</li>
<li>route         路由管理</li>
<li>rule          路由策略</li>
<li>maddr         多址广播地址</li>
<li>mroute        多播路由缓存管理</li>
<li>tunnel        通道管理</li>
</ul>


<p>``` bash</p>

<h1>ip -V         #打印iproute信息</h1>

<p>ip utility, iproute2-ss091226
```</p>

<p><strong>显示链路信息</strong>
``` bash</p>

<h1>ip link</h1>

<p>1: lo: &lt;LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue state UNKNOWN</p>

<pre><code>link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</code></pre>

<p>2: eth0: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN qlen 1000</p>

<pre><code>link/ether 00:0c:29:3b:9c:6f brd ff:ff:ff:ff:ff:ff 
</code></pre>

<h1>ip link show dev eth0</h1>

<p>2: eth0: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN qlen 1000</p>

<pre><code>link/ether 00:0c:29:3b:9c:6f brd ff:ff:ff:ff:ff:ff
</code></pre>

<p>```</p>

<p><strong>显示IP地址</strong>
``` bash</p>

<h1>ip addr</h1>

<p>1: lo: &lt;LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue state UNKNOWN</p>

<pre><code>link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
inet6 ::1/128 scope host 
   valid_lft forever preferred_lft forever
</code></pre>

<p>2: eth0: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN qlen 1000</p>

<pre><code>link/ether 00:0c:29:3b:9c:6f brd ff:ff:ff:ff:ff:ff
inet 192.168.0.10/24 brd 192.168.0.255 scope global eth0
</code></pre>

<p>```</p>

<p>显示路由<code>ip route</code> [类似<code>route -n</code>]
``` bash</p>

<h1>ip route | column -t</h1>

<p>192.168.0.0/24  dev  eth1          scope  link
10.2.0.0/16     dev  eth2          proto  kernel  scope  link  src  10.2.0.111
default         via  10.2.255.254  dev    eth2</p>

<h1>ip route del 192.168.0.0/24 dev eth1</h1>

<h1>ip route add 192.168.0.0/24 dev eth1</h1>

<h1>ip route del via 10.2.255.254  //删除默认路由</h1>

<h1>ip route add via 10.2.255.254  //增加默认路由</h1>

<h1>ip route add 192.168.1.0/24 via 192.168.0.1  //增加静态路由，192.168.0.1为下一跳地址</h1>

<h1>ip route del 192.168.1.0/24 via 192.168.0.1  //删除静态路由</h1>

<p>```</p>

<p>显示arp信息<code>ip neigh</code> [可以取代<code>arp -n</code>],删除则是<code>ip neigh del IP地址 dev 设备名</code></p>

<h3>路由策略数据库</h3>

<p>如果你有一个大规模的路由器，需要同时满足不同用户对于路由的不通需求，路由策略数据库可以帮你通过多路由表技术来实现。当内核需要做出路由选择时，它会找出应该参考哪一张路由表。除了<code>ip</code>外,<code>route</code>也可以修改main和local表。</p>

<p><strong>默认规则</strong>
``` bash</p>

<h1>ip rule</h1>

<p>0:  from all lookup local
32766:  from all lookup main
32767:  from all lookup default
```</p>

<p>上面列出了规则的优先顺序。<code>ip route</code>命令默认显示的就是main表。<code>ip route show table all</code>显示所有规则中的表</p>

<p>``` bash</p>

<h1>ip route list table local</h1>

<p>broadcast 192.168.0.255 dev eth0  proto kernel  scope link  src 192.168.0.10
broadcast 10.2.0.0 dev eth1  proto kernel  scope link  src 10.2.0.217
broadcast 127.255.255.255 dev lo  proto kernel  scope link  src 127.0.0.1
... ...
```</p>

<p>default表为空</p>

<h3>例 简单策略路由添加 [引用自<a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;cad=rja&amp;ved=0CDkQFjAB&amp;url=%68%74%74%70%3a%2f%2f%77%77%77%2e%6c%61%72%74%63%2e%6f%72%67%2f%4c%41%52%54%43%2d%7a%68%5f%43%4e%2e%47%42%32%33%31%32%2e%70%64%66&amp;ei=4XeuUc3RPIG1lQW1voGwAg&amp;usg=AFQjCNEI4pFvc81u0hYutCtbC4mEoh44qA&amp;sig2=Txgnxnm1LMqWL87RKUsWDQ">Linux高级路由中文HOWTO</a>]</h3>

<p>让我们再来一个真实的例子。我有两个Cable Modem，连接到了一个 Linux的NAT (“伪装”) 路由器上。这里的室友们向我付费使用Internet。假如我其中的一个室友因为只想访问 hotmail 而希望少付一些钱。对我来说这没有问题,他们肯定只能使用那个比较次的Cable Modem。</p>

<p>那个比较快的cable modem 的IP地址是 212.64.94.251，PPP 链路，对端IP是212.64.94.1。而那个比较慢的cable modem的IP地址是212.64.78.148，对端是195.96.98.253。</p>

<p>local 表：
<code>bash
[ahu@home ahu]$ ip route list table local
broadcast 127.255.255.255 dev lo proto kernel scope link src 127.0.0.1
local 10.0.0.1 dev eth0 proto kernel scope host src 10.0.0.1
broadcast 10.0.0.0 dev eth0 proto kernel scope link src 10.0.0.1
local 212.64.94.251 dev ppp0 proto kernel scope host src 212.64.94.251
broadcast 10.255.255.255 dev eth0 proto kernel scope link src 10.0.0.1
broadcast 127.0.0.0 dev lo proto kernel scope link src 127.0.0.1
local 212.64.78.148 dev ppp2 proto kernel scope host src 212.64.78.148
local 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1
local 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1
</code></p>

<p>让我们看看“main”路由表：
<code>bash
[ahu@home ahu]$ ip route list table main
195.96.98.253 dev ppp2 proto kernel scope link src 212.64.78.148
212.64.94.1 dev ppp0 proto kernel scope link src 212.64.94.251
10.0.0.0/8 dev eth0 proto kernel scope link src 10.0.0.1
127.0.0.0/8 dev lo scope link
default via 212.64.94.1 dev ppp0
</code></p>

<p>我们现在为我们的朋友创建了一个叫做“John”的规则。其实我们完全可以使用纯数字表示规则，但是不方便。我们可以向<code>/etc/iproute2/rt_tables</code>文件中添加数字与名字的关联：
``` bash</p>

<h1>echo 200 John >> /etc/iproute2/rt_tables</h1>

<h1>ip rule add from 10.0.0.10 table John</h1>

<h1>ip rule</h1>

<p>0:  from all lookup local
32765:  from 10.0.0.10 lookup John
32766:  from all lookup main
32767:  from all lookup default
```</p>

<p>现在，剩下的事情就是为 John 的路由表创建路由项了。别忘了刷新路由缓存：
``` bash</p>

<h1>ip route add default via 195.96.98.253 dev ppp2 table John</h1>

<h1>ip route flush cache</h1>

<p>```</p>

<p>总结主要是以下几步：</p>

<ul>
<li>echo 200 John >> /etc/iproute2/rt_tables #方便表示，把规则名字和数字对应加入到<code>/etc/iproute2/rt_tables</code>文件</li>
<li>ip rule add from 10.0.0.10 table John    #新增规则</li>
<li>ip route add default via 195.96.98.253 dev ppp2 table John #规则中添加路由表</li>
<li>ip route flush cache  #刷新路由表</li>
</ul>


<p>--EOF--</p>

<p>未完待续<br/>
下一篇预报--Linux下高级路由</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[top基本介绍]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/06/02/top/"/>
    <updated>2013-06-02T09:49:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/06/02/top</id>
    <content type="html"><![CDATA[<p><code>top</code>命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。下面跟着笔者一起<code>top</code>一下吧：</p>

<!--more-->


<p>``` bash</p>

<h1>top</h1>

<p>top - 10:52:40 up 3 days, 52 min,  1 user,  load average: 57.28, 112.40, 123.60
Tasks:  99 total,   1 running,  98 sleeping,   0 stopped,   0 zombie
Cpu(s): 19.5%us, 11.4%sy,  0.0%ni,  0.0%id, 65.7%wa,  0.0%hi,  3.4%si,  0.0%st
Mem:  16435896k total, 16232468k used,   203428k free,    58004k buffers
Swap:  1044476k total,   713552k used,   330924k free, 10052032k cached</p>

<p>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
  ... ...
```</p>

<p>统计信息区前五行是系统整体的统计信息。第一行是任务队列信息，同uptime命令的执行结果。其内容如下：</p>

<table class="table table-striped">
    <tr>
        <td>10:52:40</td>
        <td>当前时间</td>
    </tr>
    <tr>
        <td>up 3 days, 52 min</td>
        <td>系统运行时间</td>
    </tr>
    <tr>
        <td>1 users</td>
        <td>当前登录用户数</td>
    </tr>
    <tr>
        <td>load average: 57.28, 112.40, 123.60</td>
        <td>系统负载，即任务队列平均长度。
        <br>分别为1、5、15min前到现在平均值。</br></td>
    </tr>
</table>


<p></p>


<p>第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行。内容如下：</p>

<table>
    <tr>
        <td>Tasks:99 total</td>
        <td>进程总数[键入H可查看线程数]</td>
    </tr>
    <tr>
        <td>1 running,  98 sleeping,  0 stopped</td>
        <td>正在运行的进程、睡眠进程、停止的进程</td>
    </tr>
    <tr>
        <td>0 zombie</td>
        <td>僵尸进程数</td>
    </tr>
    <tr>
        <td>Cpu(s): 19.5%us, 11.4%sy,  
        <br> 0.0%ni, 0.0%id,</br> 
        65.7%wa, 0.0%hi, 3.4%si, 0.0%st</td>
        <td>用户空间占用CPU百分比、内核空间占用CPU百分比
        <br>用户进程空间内改变进程优先级占用CPU、空闲CPU百分比</br>
        等待IO的CPU时间百分比，最后三个是中断请求相关</td>
    </tr>
</table>




<p></p>


<p>倒数第2、3行为内存相关信息：</p>

<table>
    <tr>
        <td>Mem: 16435896k total, 16232468k used, 
        <br>203428k free, 58004k buffers</br></td>
        <td>分别是物理内存总量、使用物理内存总量
        <br>空闲内存总量、用作内核缓存内存量</br></td>
    </tr>
    <tr>
        <td>Swap: 1044476k total, 713552k used, 
        <br>330924k free, 10052032k cached<br></td>
        <td>分别是交换分区量、使用交换分区总量
        <br>空闲交换区总量、缓存交换区总量</br></td>
    </tr>
</table>


<p></p>


<p><strong>buffer</strong>   <a href="http://wiki.answers.com/Q/Difference_between_buffer_and_cache">Difference between buffer and cache?</a></p>

<blockquote><p>A data area, shared by hardware devices or program a process is called buffer. They are operated at different speeds or with different sets of priorities. The buffer allows each device or process to operate without holding up by the other. In order to a buffer to be effective, the size of the buffer needs to be considered by the buffer designer. Like a cache, a buffer is a "midpoint holding place" but does not exist so much to accelerate the speed of an activity as for supporting the coordination of separate activities.</p></blockquote>

<p></p>


<p></p>

<blockquote><p>This term is used not only in programming but in hardware as well. In programming, buffering sometimes needs to screen data from its final intended place so that it can be edited or processed before moving to a regular file or database.</p></blockquote>

<p><strong>cached</strong></p>

<blockquote><p>Cache memory is type of random access memory (RAM). Cache Memory can be accessed more quickly by the computer microprocessor than it can be accessed by regular RAM. Like microprocessor processes data, it looks first in the cache memory and if there, it finds the data from a previous reading of data, it does not need to do the more time consuming reading of data from larger memory.</p></blockquote>

<p></p>


<blockquote><p>Sometimes Cache memory is described in levels of closeness and convenience to the microprocessor. An L1 cache is on the same chip like the microprocessors.</p></blockquote>

<p></p>


<p></p>

<blockquote><p>In addition to cache memory, RAM itself is a cache memory for hard disk storage since all of RAM's contents come up to the hard disk initially when you turn on your computer and load the operating system that you are loading it into RAM and later when you start new applications and access new data. RAM also contains a special area called a disk cache that consists of the data most recently read in from the hard disk.</p></blockquote>

<p></p>


<p>最后1行则是进程相关的资源占用信息:</p>

<ul>
<li>PID：进程的ID</li>
<li>USER：进程所有者</li>
<li>PR：进程的优先级别，越小越优先被执行</li>
<li>NI：nice值。负值表示高优先级，正值表示低优先级</li>
<li>VIRT：进程占用的虚拟内存</li>
<li>RES：进程占用的物理内存</li>
<li>SHR：进程使用的共享内存</li>
<li>S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</li>
<li>%CPU：进程占用CPU的使用率</li>
<li>%MEM：进程使用的物理内存和总内存的百分比</li>
<li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。</li>
<li>COMMAND：进程启动命令名称</li>
</ul>


<p>--EOF--</p>

<p>top实践--<a href="http://kumu-linux.github.io/blog/2013/06/07/top-hacks/">top实践小技巧</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dmidecode]]></title>
    <link href="http://kumu-Linux.github.io/blog/2013/04/27/dmidecode/"/>
    <updated>2013-04-27T07:39:00+08:00</updated>
    <id>http://kumu-Linux.github.io/blog/2013/04/27/dmidecode</id>
    <content type="html"><![CDATA[<p>在介绍dmidecode命令之前，先介绍一下DMI。所谓DMI，即DesktopManagement Interface。也有被称为SMBIOS，即System Management BIOS。DMI表的意义在于让我们在不探测硬件实体的情况下获取硬件的部分信息，方便了用户，但也同时表明，表中的信息可能是不可靠的。</p>

<!--more-->


<p><code>dmidecode</code>的作用则是将DMI表中的信息用人可以读懂的方式显示出来。</p>

<p>最简单的使用方法，它将显示dmidecode所能获取到的全部dmi信息：
``` bash</p>

<h1>dmidecode</h1>

<p>```</p>

<p>但是显示所有的信息不便于我们获取想要获取的信息，那么就需要结合其它选项获取信息</p>

<p><strong>常用参数:</strong></p>

<ul>
<li>-q 或 --quiet

<ul>
<li>不显示太多信息，比如某条数据是从哪里读来的等等，为了得到简洁的信息，此条很有用</li>
</ul>
</li>
<li>-t 或 --type TYPE

<ul>
<li>指定要显示类型的信息</li>
</ul>
</li>
<li>-s 或 --string KEYWORD

<ul>
<li>显示特定的关键字</li>
</ul>
</li>
</ul>


<p><strong>-t或--type后的文本参数</strong></p>

<pre><code>bios        bios的各项信息
system      系统信息，在我的笔记本上可以看到版本、型号、序号等信息。
baseboard   主板信息
chassis     底板信息
processor   CPU的详细信息
memory      内存信息，包括目前插的内存条数及大小，支持的单条最大内存和总内存大小等
cache       缓存信息
connector   PCI设备信息
slot        插槽信息 
</code></pre>

<p>``` bash</p>

<h1>dmidecode -t</h1>

<p>dmidecode: option requires an argument -- 't'
Type number or keyword expected
Valid type keywords are:
  bios
  system
  baseboard
  chassis
  processor
  memory
  cache
  connector
  slot
```</p>

<p><strong>dmidecode -s</strong>:
``` bash</p>

<h1>dmidecode -s</h1>

<p>dmidecode: option requires an argument -- 's'
String keyword expected
Valid string keywords are:
  bios-vendor
  bios-version
  bios-release-date
  system-manufacturer
  system-product-name
  system-version
  system-serial-number
  system-uuid
  baseboard-manufacturer
  baseboard-product-name
  baseboard-version
  baseboard-serial-number
  baseboard-asset-tag
  chassis-manufacturer
  chassis-type
  chassis-version
  chassis-serial-number
  chassis-asset-tag
  processor-family
  processor-manufacturer
  processor-version
  processor-frequency
```</p>

<p><strong>常用命令举例</strong></p>

<ul>
<li>1、查看服务器型号：dmidecode | grep 'Product Name'</li>
<li>2、查看系统序列号：dmidecode -s system-serial-number</li>
<li>3、查看内存信息：dmidecode -t memory</li>
<li>4、查看OEM信息：dmidecode -t 11</li>
</ul>


<p>--EOF--</p>
]]></content>
  </entry>
  
</feed>
